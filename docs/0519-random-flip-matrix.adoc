[#0519-random-flip-matrix]
= 519. 随机翻转矩阵

https://leetcode.cn/problems/random-flip-matrix/[LeetCode - 519. 随机翻转矩阵^]

给你一个 `m x n` 的二元矩阵 `matrix` ，且所有值被初始化为 `0`。请你设计一个算法，随机选取一个满足 `matrix[i][j] == 0` 的下标 `(i, j)` ，并将它的值变为 `1` 。所有满足 `matrix[i][j] == 0` 的下标 `(i, j)` 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 `Solution` 类：

* `Solution(int m, int n)` 使用二元矩阵的大小 `m` 和 `n` 初始化该对象
* `int[] flip()` 返回一个满足 `matrix[i][j] == 0` 的随机下标 `[i, j]` ，并将其对应格子中的值变为 `1`
* `void reset()` 将矩阵中所有的值重置为 `0`

*示例：*

....
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
....

*提示：*

* `1 \<= m, n \<= 10^4^
* 每次调用`flip` 时，矩阵中至少存在一个值为 0 的格子。
* 最多调用 `1000` 次 `flip` 和 `reset` 方法。


== 思路分析

双指针。由于数字太大，无法保存所有的坐标点，所以构建未使用的坐标点，然后再删除行不通。反过来，记录已经使用的点，随机生成的坐标如果已经翻转，则向两边扩散，这样就可以保存更少的坐标，就能满足内存要求了。


[[src-0519]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0519_RandomFlipMatrix.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0519_RandomFlipMatrix_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/random-flip-matrix/solutions/1124467/gong-shui-san-xie-note-bie-pian-yi-ti-sh-e6gi/[519. 随机翻转矩阵 - 一题双解 :「双指针」&「哈希 swap」^]
. https://leetcode.cn/problems/random-flip-matrix/solutions/1123118/sui-ji-fan-zhuan-ju-zhen-by-leetcode-sol-pfmr/[519. 随机翻转矩阵 - 官方题解^]
