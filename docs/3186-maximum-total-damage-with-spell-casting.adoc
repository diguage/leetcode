[#3186-maximum-total-damage-with-spell-casting]
= 3186. 施咒的最大总伤害

https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/[LeetCode - 3186. 施咒的最大总伤害^]

一个魔法师有许多不同的咒语。

给你一个数组 `power`，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。

已知魔法师使用伤害值为 `power[i]` 的咒语时，他们就 *不能* 使用伤害为 `power[i] - 2` ，`power[i] - 1` ，`power[i] + 1` 或者 `power[i] + 2` 的咒语。

每个咒语最多只能被使用 *一次* 。

请你返回这个魔法师可以达到的伤害值之和的 *最大值* 。

*示例 1：*

....
输入：power = [1,1,3,4]
输出：6
解释：
可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。
....

*示例 2：*

....
输入：power = [7,1,6,6]
输出：13
解释：
可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。
....

*提示：*

* `1 \<= power.length \<= 10^5^`
* `1 \<= power[i] \<= 10^9^`



== 思路分析

有点懵逼！有点绕，需要把原始数组，按照伤害值转化成新的数组，这样就可以在新数组上，使用类似“打家劫舍”的套路来解题了。与“打家劫舍”套路不同的是，这里“选”的时候，前面被选择的项不是一个固定的项，是根据伤害条件选择出来的项。

stem:[$ f(i) = \max_{power_{j} < power_{i} - 2} f(j) + power_{i} \times count_{i} $]


[[src-3186]]
[tabs]
====
一刷(暴力破解)::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_3186_MaximumTotalDamageWithSpellCasting_1a.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_3186_MaximumTotalDamageWithSpellCasting_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/[3186. 施咒的最大总伤害 - 套路】值域打家劫舍^]
. https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/3803188/cong-ling-tui-dao-ji-yi-hua-dfs-zheng-fa-zo21/[3186. 施咒的最大总伤害 - 【从零推导】记忆化DFS + 正反向DP + 空间优化，双指针比二分更好^]
. https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/3801010/shi-zhou-de-zui-da-zong-shang-hai-by-lee-e2kq/[3186. 施咒的最大总伤害 - 官方题解^]
