[#tree]
= 树

树的遍历，如果用递归，代码写起来很简单。但是用遍历，又该如何做呢？

凡是用递归能解决的问题，都可以使用遍历来解决。用递归来求解问题，无非就是使用了方法栈来保存相关信息。同样，可以使用 `Stack` 来自己动手维护这些信息。例如：

xref:0144-binary-tree-preorder-traversal.adoc[144. Binary Tree Preorder Traversal^]


搜索二叉树，一个隐含的性质是如果中序遍历，其值是单调递增的。所以，如果两个节点交换位置了，则第一个错误节点是比较大的节点（后面的跑前面了），第二个错误节点为较小的节点（后面的跑前面了）。如果是相邻节点交换，也是类似。

将一棵搜索二叉树按后序遍历生成一个数组。那么，数组最后一个元素就是根节点，同时，从后向前遍历，第一个小于根节点值的地方就是左右树的分界线。然后再递归解析。就可以重建这棵搜索二叉树了。

== 树形 DP 套路

树形 DP 套路使用前提：如果题目求解目标是 S 规则，则求解流程可以定成以每一个节点为头节点的子树在 S 规则下的每一个答案，并且最终答案一定在其中。

. 以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。
. 根据第一步的可能性分析，列出所有需要的信息。
. 合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。
. 设计递归函数，递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case，默认直接得到左树和右树的所有信息，以及把可能性整合，并且要返回第三步的信息结构这四个小步骤。
