[#0443-string-compression]
= 443. 压缩字符串

https://leetcode.cn/problems/string-compression/[LeetCode - 443. 压缩字符串 ^]

给你一个字符数组 `chars` ，请使用下述算法压缩：

从一个空字符串 `s` 开始。对于 `chars` 中的每组 *连续重复字符* ：

* 如果这一组长度为 `1` ，则将字符追加到 `s` 中。
* 否则，需要向 `s` 追加字符，后跟这一组的长度。

压缩后得到的字符串 `s` *不应该直接返回* ，需要转储到字符数组 `chars` 中。需要注意的是，如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符。

请在 *修改完输入数组后* ，返回该数组的新长度。

你必须设计并实现一个只使用常量额外空间的算法来解决此问题。

*示例 1：*

....
输入：chars = ["a","a","b","b","c","c","c"]
输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
解释："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
....

*示例 2：*

....
输入：chars = ["a"]
输出：返回 1 ，输入数组的前 1 个字符应该是：["a"]
解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。
....

*示例 3：*

....
输入：chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
解释：由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
....

*提示：*

* `+1 <= chars.length <= 2000+`
* `chars[i]` 可以是小写英文字母、大写英文字母、数字或符号



== 思路分析

使用双指针的思路：一个指针 `fast` 指向当前处理的下标，一个指针 `curr` 指向当前循环的起始位置，最后一个指针 `slow` 指向可以存放压缩字符的位置。头两个指针可以合并成一个指针+数量。不断向前循环统计数量，向后压缩。

[[src-0443]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0443_StringCompression.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0443_StringCompression_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/string-compression/solutions/948718/gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu/[443. 压缩字符串 - 双指针原地算法^]
. https://leetcode.cn/problems/string-compression/solutions/948671/pythonjava-san-zhi-zhen-by-himymben-cbrd/[443. 压缩字符串 - 三指针^]
. https://leetcode.cn/problems/string-compression/solutions/948556/ya-suo-zi-fu-chuan-by-leetcode-solution-kbuc/[443. 压缩字符串 - 官方题解^]
. https://leetcode.cn/problems/string-compression/solutions/948834/tong-ge-lai-shua-ti-la-du-xie-zhi-zhen-m-n0gt/[443. 压缩字符串 - 读写指针模拟 & 论读写指针在源码中的应用！^]
