[#2466-count-ways-to-build-good-strings]
= 2466. 统计构造好字符串的方案数

https://leetcode.cn/problems/count-ways-to-build-good-strings/[LeetCode - 2466. 统计构造好字符串的方案数^]

给你整数 `zero` ，`one` ，`low` 和 `high`，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：

* 将 `0` 在字符串末尾添加 `zero`  次。
* 将 `1` 在字符串末尾添加 `one` 次。

以上操作可以执行任意次。

如果通过以上过程得到一个 *长度* 在 `low` 和 `high` 之间（包含上下边界）的字符串，那么这个字符串我们称为 *好* 字符串。

请你返回满足以上要求的 *不同* 好字符串数目。由于答案可能很大，请将结果对 `10^9^ + 7` *取余* 后返回。

*示例 1：*

....
输入：low = 3, high = 3, zero = 1, one = 1
输出：8
解释：
一个可能的好字符串是 "011" 。
可以这样构造得到："" -> "0" -> "01" -> "011" 。
从 "000" 到 "111" 之间所有的二进制字符串都是好字符串。
....

*示例 2：*

....
输入：low = 2, high = 3, zero = 1, one = 2
输出：5
解释：好字符串为 "00" ，"11" ，"000" ，"110" 和 "011" 。
....

*提示：*

* `1 \<= low \<= high \<= 10^5^`
* `1 \<= zero, one \<= low`


== 思路分析

[.line-through]#还是爬楼梯！脑子转不过来弯！#

爬楼梯解法：stem:[$f(i) = f(i−zero) + f(i − one)$]。

[[src-2466]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_2466_CountWaysToBuildGoodStrings.java[tag=answer]
----
--

二刷(暴力破解)::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_2466_CountWaysToBuildGoodStrings_2a.java[tag=answer]
----
--

二刷(备忘录)::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_2466_CountWaysToBuildGoodStrings_2b.java[tag=answer]
----
--

二刷(动态规划)::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_2466_CountWaysToBuildGoodStrings_2c.java[tag=answer]
----
--
====

TIP: 还可以利用最大公约数来优化时间复杂度。回头可以看看。


== 参考资料

. https://leetcode.cn/problems/count-ways-to-build-good-strings/solutions/1964910/by-endlesscheng-4j22/[2466. 统计构造好字符串的方案数 - 爬楼梯换皮^] -- 最后的优化真是太绝了！
. https://leetcode.cn/problems/count-ways-to-build-good-strings/solutions/2575172/2466-tong-ji-gou-zao-hao-zi-fu-chuan-de-r5k5n/[2466. 统计构造好字符串的方案数^]
