[#0056-merge-intervals]
= 56. 合并区间

https://leetcode.cn/problems/merge-intervals/[LeetCode - 56. 合并区间^]

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start~i~, end~i~]`。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

*示例 1：*

....
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
....

*示例 2：*

....
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
....

*提示：*

* `1 \<= intervals.length \<= 10^4^`
* `intervals[i].length == 2`
* `0 \<= start~i~ \<= end~i~ \<= 10^4^`



== 思路分析

在没有排序之前，两个区间有六种关系：

image::images/0056-01.png[{image_attr}]

观察这六种排序，明显后三种排序是前三种排序的一个“变种”：对区间根据起点和终点进行排序，就是剩下前三种排序了。再对其进行合并就很简单了：

. 没有重叠，则直接开启新区间。
. 有重叠，起点和终点分别取最大值和最小值即可：由于区间已经排序，则相邻两个区间的起点是前面区间的起点，重点则是两个区间终点的最大值。

TIP: 使用双指针，直接在原始数组上进行更新，最节省内存。


[[src-0056]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0056_MergeIntervals.java[tag=answer]
----
--

二刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0056_MergeIntervals_2.java[tag=answer]
----
--

三刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0056_MergeIntervals_3.java[tag=answer]
----
--

四刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0056_MergeIntervals_4.java[tag=answer]
----
--
====


== 参考资料

. https://leetcode.cn/problems/merge-intervals/solutions/2798138/jian-dan-zuo-fa-yi-ji-wei-shi-yao-yao-zh-f2b3/[56. 合并区间 - 为什么要按照左端点排序？^]
. https://leetcode.cn/problems/merge-intervals/solutions/203562/he-bing-qu-jian-by-leetcode-solution/[56. 合并区间 - 官方题解^]
. https://leetcode.cn/problems/merge-intervals/solutions/204898/tan-xin-suan-fa-java-by-liweiwei1419-3/[56. 合并区间 - 力扣（LeetCode）^]
