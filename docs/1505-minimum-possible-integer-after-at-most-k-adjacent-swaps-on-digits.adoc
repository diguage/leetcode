[#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits]
= 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits

{leetcode}/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/[LeetCode - 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits ^]

You are given a string `num` representing *the digits* of a very large integer and an integer `k`. You are allowed to swap any two adjacent digits of the integer *at most* `k` times.

Return _the minimum integer you can obtain also as a string_.

 
<strong class="example">Example 1:*
<img alt="" src="https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg" style="width: 500px; height: 40px;" />
[subs="verbatim,quotes"]
----
*Input:* num = "4321", k = 4
*Output:* "1342"
*Explanation:* The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.
----

<strong class="example">Example 2:*

[subs="verbatim,quotes"]
----
*Input:* num = "100", k = 1
*Output:* "010"
*Explanation:* It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.
----

<strong class="example">Example 3:*

[subs="verbatim,quotes"]
----
*Input:* num = "36789", k = 1000
*Output:* "36789"
*Explanation:* We can keep the number without any swaps.
----

 
*Constraints:*


* `1 <= num.length <= 3 * 10^4^`
* `num` consists of only *digits* and does not contain *leading zeros*.
* `1 <= k <= 10^9^`




== 思路分析


[[src-1505]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_1505_MinimumPossibleIntegerAfterAtMostKAdjacentSwapsOnDigits.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_1505_MinimumPossibleIntegerAfterAtMostKAdjacentSwapsOnDigits_2.java[tag=answer]
// ----
// --
====


== 参考资料


