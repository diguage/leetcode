[#0447-number-of-boomerangs]
= 447. 回旋镖的数量

https://leetcode.cn/problems/number-of-boomerangs/[LeetCode - 447. 回旋镖的数量 ^]

给定平面上 `n` 对 *互不相同* 的点 `points` ，其中 `points[i] = [x~i~, y~i~]` 。*回旋镖* 是由点 `(i, j, k)` 表示的元组，其中 `i` 和 `j` 之间的欧式距离和 `i` 和 `k` 之间的欧式距离相等（*需要考虑元组的顺序*）。

返回平面上所有回旋镖的数量。


*示例 1：*

....
输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
....

*示例 2：*

....
输入：points = [[1,1],[2,2],[3,3]]
输出：2
....

*示例 3：*

....
输入：points = [[1,1]]
输出：0
....


*提示：*

* `n == points.length`
* `+1 <= n <= 500+`
* `points[i].length == 2`
* `-10^4^ \<= x~i~, y~i~ \<= 10^4^`
* 所有点都 *互不相同*


== 思路分析

暴力破解，时间复杂度为： stem:[O(n^3)]。 通过 25/32 个测试用例。

利用排列组合原理，stem:[A_{n}^{k}=\frac{n!}{( n-k)!}]。统计相同距离的点数，组成的回旋镖需要两个点，则数量为：stem:[A_{n}^{2}=\frac{n!}{(n-2)!} = n(n-1)]。可以将时间复杂度降低为： stem:[O(n^2)]。

[[src-0447]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0447_NumberOfBoomerangs.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0447_NumberOfBoomerangs_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/number-of-boomerangs/solutions/994189/hui-xuan-biao-de-shu-liang-by-leetcode-s-lft5/[447. 回旋镖的数量 - 官方题解^]
. https://leetcode.cn/problems/number-of-boomerangs/solutions/2595488/jian-ji-xie-fa-fu-xiang-si-ti-mu-pythonj-39p8/[447. 回旋镖的数量 - 简洁写法，附相似题目^] -- 这个解法也非常不错！
