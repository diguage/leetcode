[#0451-sort-characters-by-frequency]
= 451. 根据字符出现频率排序

https://leetcode.cn/problems/sort-characters-by-frequency/[LeetCode - 451. 根据字符出现频率排序 ^]

给定一个字符串 `s` ，根据字符出现的 *频率* 对其进行 *降序排序*。一个字符出现的 *频率* 是它出现在字符串中的次数。

返回 _已排序的字符串_。如果有多个答案，返回其中任何一个。

*示例 1:*

....
输入: s = "tree"
输出: "eert"
解释: 'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
....

*示例 2:*

....
输入: s = "cccaaa"
输出: "cccaaa"
解释: 'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
....

*示例 3:*

....
输入: s = "Aabb"
输出: "bbAa"
解释: 此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
....

*提示:*

* `1 \<= s.length \<= 5 * 10^5^`
* `s` 由大小写英文字母和数字组成


== 思路分析

使用 `Map` 统计每个字符的数量，然后使用 `SequencedMap` 根据 `Map` 中统计的每个字符串数量倒序排列。有一点需要注意：如果两个字符的数量相等时，还需要根据自身的自然顺序排序，否则就会被 `SequencedMap` 吞掉一个。

[[src-0451]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0451_SortCharactersByFrequency.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0451_SortCharactersByFrequency_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/sort-characters-by-frequency/solutions/855902/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/[451. 根据字符出现频率排序 - 数据结构运用模拟题^]
. https://leetcode.cn/problems/sort-characters-by-frequency/solutions/855833/gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-by-l-zmvy/[451. 根据字符出现频率排序 - 官方题解^]
. https://leetcode.cn/problems/sort-characters-by-frequency/solutions/51233/451-gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-san-chong-/[451. 根据字符出现频率排序 - 四种方法（vector排序+优先队列+lambda表达式+数组下标索引）^]
