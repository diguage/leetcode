[#0000-25-subsets]
= Subsets 子集

超级多的编程面试问题都会涉及到排列和组合问题。一般都是使用回溯来解决该类问题，回溯法属于 DFS 解法。子集问题模式讲的是用 BFS 来处理这些问题。


== 子集

举例来说明一下这个模式：

给一组数字 `[1, 5, 3]`

. 我们从空集开始：`[[]]`
. 把第一个数 `1`，加到之前已经存在的集合中：`[[], [1]]`;
. 把第二个数 `5`，加到之前的集合中得到：`[[], [1], [5], [1,5]]`;
. 再加第三个数 `3`，则有：`[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]`.

如果原有集合中存在重复元素，那么就需要针对这种情况特殊处理一下。流程如下：

给一组数字 `[5, 1, 5]`

. 先对原有集合进行排序： `[1, 5, 3]`
. 从空集开始：`[[]]`
. 把第一个数 `1`，加到之前已经存在的集合中：`[[], [1]]`;
. 把第二个数 `5`，加到之前的集合中得到：`[[], [1], [5], [1,5]]`;
. 处理第三个数，也是 `5` 时需要注意：
.. 如果还是按照上述方案处理，那么就会得到如下结果： `[[], [1], [5], [1,5], *[5], [1, 5]*, [5, 5], [1,5, 5]]`。这里出现了重复子集： `[5], [1, 5]`。该方案不通过，❌
.. 观察最后生成的所有子集与重复的子集，会发现重复的子集，在处理第二个数时，已经处理过 `[], [1]`，如果再次处理 `5`，那么就会出现重复。所以，只需要处理在处理上一个相同的数时新增加的子集即可。上一个相同数新增的子集是 `[5], [1,5]`，只需要在这些子集后面增加当前数字即可。这样最后的子集就是：`[[], [1], [5], [1,5], [5, 5], [1,5, 5]]`。方案通过 ✅

== 排列

举例来说明一下这个模式在处理排列问题时的步骤：

给一组数字 `[1, 5, 3]`

. 把第一个数 `1`，集合中：`[[1]]`;
. 把第二个数 `5`，加到之前的集合中得到，由于 `[1, 5]` 和 `[5, 1]` 属于两个排列，那么就需要在所有可能的位置都增加一下，最后得到的排列如下：：`[[5, 1], [1,5]]`;
. 再加第三个数 `3`，也是如上，在所有可能的位置都增加，最终排列如下：`[[3, 5, 1], [5, 3, 1],[5, 1, 3], [3, 1, 5], [1, 3, 5], [1, 5, 3]]`。

思考一下：如何处理有重复元素的排列？

// [1, 5, 5]
//
// `[[1]]`
//
// `[[5, 1], [1,5]]`
//
// `[[5, 5, 1], *[5, 5, 1]*,[5, 1, 5], *[5, 1, 5]*, [1, 5, 5], *[1, 5, 5]*]`


如果判断这种子集模式：

* 问题需要咱们去找数字的组合或是排列

== 经典题目

. xref:0022-generate-parentheses.adoc[22. Generate Parentheses]
. xref:0046-permutations.adoc[46. Permutations]
. xref:0078-subsets.adoc[78. Subsets]
. xref:0090-subsets-ii.adoc[90. Subsets II]
. xref:0095-unique-binary-search-trees-ii.adoc[95. Unique Binary Search Trees II]
. xref:0096-unique-binary-search-trees.adoc[96. Unique Binary Search Trees]
. xref:0241-different-ways-to-add-parentheses.adoc[241. Different Ways to Add Parentheses]
. xref:0320-generalized-abbreviation.adoc[320. Generalized Abbreviation]
. xref:0784-letter-case-permutation.adoc[784. Letter Case Permutation]
