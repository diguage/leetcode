[#0621-task-scheduler]
= 621. 任务调度器

https://leetcode.cn/problems/task-scheduler/[LeetCode - 621. 任务调度器 ^]

给你一个用字符数组 `+tasks+` 表示的 CPU 需要执行的任务列表，用字母 A 到
Z 表示，以及一个冷却时间 `+n+`。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 *相同种类* 的任务之间必须有长度为 *`+n+`* 的冷却时间。

返回完成所有任务所需要的 *最短时间间隔*。

*示例 1：*

**输入：**tasks = ["A","A","A","B","B","B"], n = 2

**输出：**8

*解释：*

在完成任务 A 之后，你必须等待两个间隔。对任务 B 来说也是一样。在第 3
个间隔，A 和 B 都不能完成，所以你需要待命。在第 4 个间隔，由于已经经过了
2 个间隔，你可以再次执行 A 任务。



*示例 2：*

**输入：**tasks = ["A","C","A","B","D","B"], n = 1

**输出：**6

**解释：**一种可能的序列是：A -> B -> C -> D -> A -> B。

由于冷却间隔为 1，你可以在完成另一个任务后重复执行这个任务。

*示例 3：*

**输入：**tasks = ["A","A","A","B","B","B"], n = 3

**输出：**10

**解释：**一种可能的序列为：A -> B -> idle -> idle -> A -> B -> idle ->
idle -> A -> B。

只有两种任务类型，A 和 B，需要被 3
个间隔分割。这导致重复执行这些任务的间隔当中有两次待命状态。



*提示：*

* `+1 <= tasks.length <= 10+`^`+4+`^
* `+tasks[i]+` 是大写英文字母
* `+0 <= n <= 100+`



== 思路分析

这道题有三个点需要注意：

. 因为要任务休息时间，所以，出现次数最多的任务，会持续得更长，有将任务按照出现次数排序，优先安排次数多的任务。
. 结果关注的是总共需要完成的时间，所以不需要关注具体执行的是哪个任务。
. 需要"空转时间"的处理。

解题思路：

. 将任务按类型分组，正好A-Z用一个int[26]保存任务类型个数
. 对数组进行排序，优先排列个数（count）最大的任务，如题得到的时间至少为 retCount =（count-1）* (n+1) + 1 ==> A->X->X->A->X->X->A(X为其他任务或者待命)
. 再排序下一个任务，如果下一个任务B个数和最大任务数一致，则retCount++ ==> A->B->X->A->B->X->A->B
. 如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，在这种情况下就是任务的总数是最小所需时间

[[src-0621]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0621_TaskScheduler.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0621_TaskScheduler_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/task-scheduler/solutions/29894/621-ren-wu-diao-du-qi-java-jie-ti-zhu-shi-ying-gai/[621. 任务调度器 - Java--解题注释应该能看懂^] -- 这个解释清楚。
