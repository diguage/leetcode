[#0098-validate-binary-search-tree]
= 98. 验证二叉搜索树

https://leetcode.cn/problems/validate-binary-search-tree/[LeetCode - 98. 验证二叉搜索树^]

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

*有效* 二叉搜索树定义如下：

* 节点的左子树只包含 *小于* 当前节点的数。
* 节点的右子树只包含 *大于* 当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

*示例 1：*

image::images/0098-01.jpg[{image_attr}]

....
输入：root = [2,1,3]
输出：true
....

*示例 2：*

image::images/0098-02.jpg[{image_attr}]

....
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
....

*提示：*

* 树中节点数目范围在`[1, 10^4^]` 内
* `-2^31^ \<= Node.val \<= 2^31^ - 1`


== 思路分析

image::images/0098-14.png[{image_attr}]

image::images/0098-15.png[{image_attr}]

思路很简单，利用搜索二叉树的定义，界定好树的上下界，然后递归比较就好。


直接使用“树形DP套路”+剪枝技巧，速度直接击败 100%。

这里有一点需要注意：最大值最小值用 `Long.MIN_VALUE` 和 `Long.MAX_VALUE`，这样可以防止单节点树 `Integer.MAX_VALUE` （最小值的单节点树应该也会有问题）造成的错误。

另外，查看了官方题解后，发现可以使用树的中序排列来检查（二叉搜索树中序排列是升序），这样跟前几天在牛客网上做的那个“发现二叉搜索树中的两个错误节点”的思路就一致了。回头尝试一下。

image::images/0098-10.png[{image_attr}]

image::images/0098-11.png[{image_attr}]

image::images/0098-12.png[{image_attr}]

image::images/0098-13.png[{image_attr}]

[[src-0098]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0098_ValidateBinarySearchTree.java[tag=answer]
----
--

二刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0098_ValidateBinarySearchTree_2.java[tag=answer]
----
--

三刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0098_ValidateBinarySearchTree_3.java[tag=answer]
----
--
====


== 参考资料

. https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/[98. 验证二叉搜索树 - 前序中序后序，三种方法，一个视频讲透！^]
. https://leetcode.cn/problems/validate-binary-search-tree/solutions/230256/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/[98. 验证二叉搜索树 - 官方题解^]
. https://leetcode.cn/problems/validate-binary-search-tree/solutions/231280/yi-zhang-tu-rang-ni-ming-bai-shang-xia-jie-zui-da-/[98. 验证二叉搜索树 - 一张图让你明白上下界（最大值最小值）判定^]
