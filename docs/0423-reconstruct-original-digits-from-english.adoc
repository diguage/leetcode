[#0423-reconstruct-original-digits-from-english]
= 423. 从英文中重建数字

https://leetcode.cn/problems/reconstruct-original-digits-from-english/[LeetCode - 423. 从英文中重建数字 ^]

给你一个字符串 `s`，其中包含字母顺序打乱的用英文单词表示的若干数字（`0-9`）。按 *升序* 返回原始的数字。

*示例 1：*

....
输入：s = "owoztneoer"
输出："012"
....

*示例 2：*

....
输入：s = "fviefuro"
输出："45"
....

*提示：*

* `1 \<= s.length \<= 10^5^`
* `s[i]` 为 `["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"]` 这些字符之一
* `s` 保证是一个符合题目要求的字符串


== 思路分析

按照最初想法，先统计每个字符出现的次数，然后再按照数字顺序，逐个去尝试是否在字符串中。这样时间复杂度就不可控。看题解，可以按照单词中的字符出现特性，先将只出现在一个数字中的字符挑选出来，确定对应的数字出现次数。然后，在处理出现中两个数字中的字符，逐步把所有数字出现次数确定好。


|===
|字母 |数字

|e
|0 1 3 5 7 8 9

|f
|4 5

|g
|8

|h
|3 8

|i
|5 6 8 9

|n
|1 7 9

|o
|0 1 2 4

|r
|0 3 4

|s
|6 7

|t
|2 3 8

|u
|4

|v
|5 7

|w
|2

|x
|6

|z
|0
|===


[[src-0423]]
[tabs]
====
一刷::
+
--
[{java_src_attr}]
----
include::{sourcedir}/_0423_ReconstructOriginalDigitsFromEnglish.java[tag=answer]
----
--

// 二刷::
// +
// --
// [{java_src_attr}]
// ----
// include::{sourcedir}/_0423_ReconstructOriginalDigitsFromEnglish_2.java[tag=answer]
// ----
// --
====


== 参考资料

. https://leetcode.cn/problems/reconstruct-original-digits-from-english/solutions/1117147/cong-ying-wen-zhong-zhong-jian-shu-zi-by-9g1r/?envType=problem-list-v2&envId=9UZ9R3lB[423. 从英文中重建数字 - 官方题解^]
. https://leetcode.cn/problems/reconstruct-original-digits-from-english/solutions/1118849/gong-shui-san-xie-nao-jin-ji-zhuan-wan-m-vg7a/?envType=problem-list-v2&envId=9UZ9R3lB[423. 从英文中重建数字 - 脑筋急转弯模拟题^]
