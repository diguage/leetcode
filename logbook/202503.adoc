[#logbook-202503]
= 2025年03月 刷题日志
ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]


[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|⭕️ 递归解法非常妙！传一个参数，`next` 又 `next` 比较麻烦，传两个参数比较简单。

|{counter:codes2503}
|{leetcode_base_url}/find-first-and-last-position-of-element-in-sorted-array/[34. 在排序数组中查找元素的第一个和最后一个位置^]
|{doc_base_url}/0034-find-first-and-last-position-of-element-in-sorted-array.adoc[题解]
|✅ 思考清楚确定边界时，中间指针的移动方向即可迎刃而解。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点去处理有序部分，在有序部分内查找不到，则去另外一部分去查找。

|{counter:codes2503}
|{leetcode_base_url}/merge-intervals/[56. 合并区间^]
|{doc_base_url}/0056-merge-intervals.adoc[题解]
|✅ 对区间进行排序，然后快慢指针在当前数组上对其进行合并。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array-ii/[81. 搜索旋转排序数组 II^]
|{doc_base_url}/0081-search-in-rotated-sorted-array-ii.adoc[题解]
|✅ 关注有序区间，确定目标值在有序区间内，则在有序区间查找；反之，则在另外一部分内查找。另外，通过移动一个指针即可避开重复元素。

|{counter:codes2503}
|{leetcode_base_url}/two-sum/[1. 两数之和^]
|{doc_base_url}/0001-two-sum.adoc[题解]
|✅ 注意审题！返回的是数组下标。

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle/[141. 环形链表^]
|{doc_base_url}/0141-linked-list-cycle.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/happy-number/[202. 快乐数^]
|{doc_base_url}/0202-happy-number.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/minimum-window-substring/[76. 最小覆盖子串^]
|{doc_base_url}/0076-minimum-window-substring.adoc[题解]
|⭕️ 滑动窗口，一定注意细节的处理。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicate-letters/[316. 去除重复字母^]
|{doc_base_url}/0316-remove-duplicate-letters.adoc[题解]
|❌ 完全想不到单调栈！

|{counter:codes2503}
|{leetcode_base_url}/top-k-frequent-elements/[347. 前 K 个高频元素^]
|{doc_base_url}/0347-top-k-frequent-elements.adoc[题解]
|✅ Top K 问题，优先队列；桶排序

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|⭕️ 快速选择，想清楚边界情况！

|{counter:codes2503}
|{leetcode_base_url}/first-missing-positive/[41. 缺失的第一个正数^]
|{doc_base_url}/0041-first-missing-positive.adoc[题解]
|⭕️ 循环排序，看了答案，自己写出来了。

|{counter:codes2503}
|{leetcode_base_url}/find-median-from-data-stream/[295. 数据流的中位数^]
|{doc_base_url}/0295-find-median-from-data-stream.adoc[题解]
|⭕️ 双堆，思路理解，写代码却有很多问题。

|{counter:codes2503}
|{leetcode_base_url}/merge-k-sorted-lists/[23. 合并 K 个升序链表^]
|{doc_base_url}/0023-merge-k-sorted-lists.adoc[题解]
|✅ 多路归并

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-level-order-traversal/[102. 二叉树的层序遍历^]
|{doc_base_url}/0102-binary-tree-level-order-traversal.adoc[题解]
|✅ 广度优先搜索

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-maximum-path-sum/[124. 二叉树中的最大路径和^]
|{doc_base_url}/0124-binary-tree-maximum-path-sum.adoc[题解]
|⭕️ 深度优先搜索，注意处理负数情况

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-without-repeating-characters/[3. 无重复字符的最长子串^]
|{doc_base_url}/0003-longest-substring-without-repeating-characters.adoc[题解]
|✅ 滑动窗口

|{counter:codes2503}
|{leetcode_base_url}/lru-cache/[146. LRU 缓存^]
|{doc_base_url}/0146-lru-cache.adoc[题解]
|✅ 链表前后指针操作

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|✅ 两种解法：递归+迭代

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|✅ 快速选择

|{counter:codes2503}
|{leetcode_base_url}/reverse-nodes-in-k-group/[25. K 个一组翻转链表^]
|{doc_base_url}/0025-reverse-nodes-in-k-group.adoc[题解]
|✅ 分段递归反转，再拼接

|{counter:codes2503}
|{leetcode_base_url}/implement-trie-prefix-tree/[208. 实现 Trie (前缀树)^]
|{doc_base_url}/0208-implement-trie-prefix-tree.adoc[题解]
|✅ 前缀树，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/number-of-provinces/[547. 省份数量]
|{doc_base_url}/0547-number-of-provinces.adoc[题解]
|✅ 并查集，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 利用递归“降维”

|{counter:codes2503}
|{leetcode_base_url}/course-schedule/[207. 课程表^]
|{doc_base_url}/0207-course-schedule.adoc[题解]
|✅ 拓扑排序

|{counter:codes2503}
|{leetcode_base_url}/maximum-subarray/[53. 最大子数组和^]
|{doc_base_url}/0053-maximum-subarray.adoc[题解]
|⭕️ 动态规划。稀里糊涂就对了，还要对推演。另有更精妙的分治解法，抽空再尝试。

|{counter:codes2503}
|{leetcode_base_url}/merge-two-sorted-lists/[21. 合并两个有序链表^]
|{doc_base_url}/0021-merge-two-sorted-lists.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-substring/[5. 最长回文子串^]
|{doc_base_url}/0005-longest-palindromic-substring.adoc[题解]
|✅ 有更高效的马拉车算法，抽空可以尝试一下。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点关注有序部分，优先在有序部分查找，不在有序部分再去无序部分查找。注意判定有序部分的方法： `nums[0]` 与 `nums[mid]` 相比较，而不是 `nums[left]`（它的值会来回变）。

|{counter:codes2503}
|{leetcode_base_url}/number-of-islands/[200. 岛屿数量^]
|{doc_base_url}/0200-number-of-islands.adoc[题解]
|✅ 想尝试并查集，结果失败。还是沉岛大法好啊！

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/power-of-two/[231. 2 的幂^]
|{doc_base_url}/0231-power-of-two.adoc[题解]
|✅ 更巧妙的解法是位运算，如果 `n` 是 `2` 的幂，则二进制只有第一位是 `1`，减一则二进制都是 `1`，相与 `n & (n - 1)` 则为 `0`。

|{counter:codes2503}
|{leetcode_base_url}/merge-sorted-array/[88. 合并两个有序数组^]
|{doc_base_url}/0088-merge-sorted-array.adoc[题解]
|✅ `num1` 后面空着，则从后向前合并。

|{counter:codes2503}
|{leetcode_base_url}/powx-n/[50. Pow(x, n)^]
|{doc_base_url}/0050-powx-n.adoc[题解]
|✅ 递归很简单，抽空再思考一下非递归形式。

|{counter:codes2503}
|{leetcode_base_url}/sort-list/[148. 排序链表]
|{doc_base_url}/0148-sort-list.adoc[题解]
|✅ 分治

|{counter:codes2503}
|{leetcode_base_url}/ones-and-zeroes/[474. 一和零^]
|{doc_base_url}/0474-ones-and-zeroes.adoc[题解]
|❌ 动态规划，多维度“物品”就无从下手，还要多练。

|{counter:codes2503}
|{leetcode_base_url}/coin-change/[322. 零钱兑换]
|{doc_base_url}/0322-coin-change.adoc[题解]
|⭕️ 动态规划，完全背包问题

|{counter:codes2503}
|{leetcode_base_url}/subsets-ii/[90. 子集 II]
|{doc_base_url}/0090-subsets-ii.adoc[题解]
|⭕️ 子集，需要注意重复元素的处理。现在用 `Set` 记录已添加子集的方案还可以再优化。添加优化解法。

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 子集。注意对比子集模式在处理子集和排列时的不同：①子集直接在结果中添加新子集；②排列则是将结果中的元素出队，添加新元素后，再入队。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock/[121. 买卖股票的最佳时机^]
|{doc_base_url}/0121-best-time-to-buy-and-sell-stock.adoc[题解]
|✅ 遍历找最大差值

|{counter:codes2503}
|{leetcode_base_url}/lowest-common-ancestor-of-a-binary-tree/[236. 二叉树的最近公共祖先^]
|{doc_base_url}/0236-lowest-common-ancestor-of-a-binary-tree.adoc[题解]
|✅ 递归遍历查找目标节点，找到则返回，找不到则返回 `null`，当左右都不是 `null` 时，则当前节点即是最近公共祖先。

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list-ii/[92. 反转链表 II^]
|{doc_base_url}/0092-reverse-linked-list-ii.adoc[题解]
|✅ 链表反转

|{counter:codes2503}
|{leetcode_base_url}/find-the-index-of-the-first-occurrence-in-a-string/[28. 找出字符串中第一个匹配项的下标]
|{doc_base_url}/0028-find-the-index-of-the-first-occurrence-in-a-string.adoc[题解]
|✅ 暴力破解。更有的解法是 KMP 算法、Boyer-Moore 算法、Sunday 算法等算法。

|{counter:codes2503}
|{leetcode_base_url}/spiral-matrix/[54. Spiral Matrix^]
|{doc_base_url}/0054-spiral-matrix.adoc[题解]
|✅ 使用递归来推进层级。注意处理细节。另外，在“上”和“右”能覆盖“全部”（比如一行多列或者多行一列）时，才能在“下”之前根据长度返回。尝试了每段“读取”只剩一个的方案，不行，有很多意外情况要处理。

|{counter:codes2503}
|{leetcode_base_url}/add-strings/[415. 字符串相加^]
|{doc_base_url}/0415-add-strings.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/reorder-list/[143. Reorder List^]
|{doc_base_url}/0143-reorder-list.adoc[题解]
|✅ 双指针+链表反正+链表合并

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle-ii/[142. 环形链表 II^]
|{doc_base_url}/0142-linked-list-cycle-ii.adoc[题解]
|✅ 双指针+数学

|{counter:codes2503}
|{leetcode_base_url}/remove-nth-node-from-end-of-list/[19. 删除链表的倒数第 N 个结点^]
|{doc_base_url}/0019-remove-nth-node-from-end-of-list.adoc[题解]
|✅ 双指针+虚拟头节点。使用虚拟头结点会省事好多。

|{counter:codes2503}
|{leetcode_base_url}/restore-ip-addresses/[93. 复原 IP 地址^]
|{doc_base_url}/0093-restore-ip-addresses.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/n-th-tribonacci-number/[1137. 第 N 个泰波那契数^]
|{doc_base_url}/1137-n-th-tribonacci-number.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber/[198. 打家劫舍^]
|{doc_base_url}/0198-house-robber.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-ii/[213. 打家劫舍 II^]
|{doc_base_url}/0213-house-robber-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iii/[337. 打家劫舍 III^]
|{doc_base_url}/0337-house-robber-iii.adoc[题解]
|✅ 动态规划+树 = 树形动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iv/[2560. 打家劫舍 IV^]
|{doc_base_url}/2560-house-robber-iv.adoc[题解]
|❌ 看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/delete-and-earn/[740. 删除并获得点数^]
|{doc_base_url}/0740-delete-and-earn.adoc[题解]
|❌ 把题目理解错了。处理后就是最简单的打家劫舍问题。

|{counter:codes2503}
|{leetcode_base_url}/unique-paths/[62. 不同路径^]
|{doc_base_url}/0062-unique-paths.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-ii/[63. 不同路径 II^]
|{doc_base_url}/0063-unique-paths-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-iii/[980. 不同路径 III^]
|{doc_base_url}/0980-unique-paths-iii.adoc[题解]
|❌ 明知是回溯，但在处理当前节点时，总把当前和下一步混在一起。有思路，没写出代码。

|{counter:codes2503}
|{leetcode_base_url}/minimum-path-sum/[64. 最小路径和^]
|{doc_base_url}/0064-minimum-path-sum.adoc[题解]
|✅ 动态规划。直接在原有矩阵上操作即可。

|{counter:codes2503}
|{leetcode_base_url}/triangle/[120. 三角形最小路径和^]
|{doc_base_url}/0120-triangle.adoc[题解]
|✅ 动态规划。从底向上比从上向底效率更高。

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum/[931. 下降路径最小和^]
|{doc_base_url}/0931-minimum-falling-path-sum.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum-ii/[1289. 下降路径最小和  II^]
|{doc_base_url}/1289-minimum-falling-path-sum-ii.adoc[题解]
|⭕️ 动态规划。题目理解错误。

|{counter:codes2503}
|{leetcode_base_url}/maximal-square/[221. 最大正方形^]
|{doc_base_url}/0221-maximal-square.adoc[题解]
|✅ 动态规划。直接将结果存储在参数矩阵上。如果正方形想扩大，则左边，左上和上面三个都是正方形时才可以，可以直接去这三者中的最小值。

|{counter:codes2503}
|{leetcode_base_url}/word-break/[139. 单词拆分^]
|{doc_base_url}/0139-word-break.adoc[题解]
|⭕️ 回溯+备忘录。首先想到的是回溯，但是超时（通过34/47的测试用例）。参考别人题解后，得到启发，加上备忘录通过。参考答案写出了动态规划的解法。*思考如何从基于回溯+备忘录转变为动态规划？*

|{counter:codes2503}
|{leetcode_base_url}/word-break-ii/[140. 单词拆分 II^]
|{doc_base_url}/0140-word-break-ii.adoc[题解]
|✅ 回溯。没想到从 `LinkedList` 切换到 `ArrayList`，内存占用就大幅下降 43.77% → 91.82%。没有使用备忘录耗时已经击败了 98.49%。

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-subsequence/[516. 最长回文子序列^]
|{doc_base_url}/0516-longest-palindromic-subsequence.adoc[题解]
|❌ 动态规划。相当于在“结尾”中寻找回文子串。从一维字符串字符坐标去看转移方程，会更加清楚明了。

|{counter:codes2503}
|{leetcode_base_url}/container-with-most-water/[11. 盛最多水的容器^]
|{doc_base_url}/0011-container-with-most-water.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/remove-element/[27. 移除元素^]
|{doc_base_url}/0027-remove-element.adoc[题解]
|✅ 快慢指针。慢指针记录满足条件的长度，快指针指向需要处理的元素。

|{counter:codes2503}
|{leetcode_base_url}/trapping-rain-water/[42. 接雨水^]
|{doc_base_url}/0042-trapping-rain-water.adoc[题解]
|❌ 使用单调栈没写出来。使用单调栈，需 `h × w`，不能只看头顶的容量。使用左右双指针夹逼代码更简单，只需要计算头顶的容量即可。

|{counter:codes2503}
|{leetcode_base_url}/edit-distance/[72. 编辑距离^]
|{doc_base_url}/0072-edit-distance.adoc[题解]
|✅ 动态规划。思考如何进一步优化成一维数组？

|{counter:codes2503}
|{leetcode_base_url}/maximum-width-of-binary-tree/[662. 二叉树最大宽度^]
|{doc_base_url}/0662-maximum-width-of-binary-tree.adoc[题解]
|⭕️ 添加虚拟节点的做法超时。看答案给节点加编号通过。

|{counter:codes2503}
|{leetcode_base_url}/next-permutation/[31. 下一个排列^]
|{doc_base_url}/0031-next-permutation.adoc[题解]
|❌ 明白大概意思，思路不够条理，写不出代码。

|{counter:codes2503}
|{leetcode_base_url}/rotate-array/[189. 轮转数组^]
|{doc_base_url}/0189-rotate-array.adoc[题解]
|❌ 题目理解错误，是轮转数组，不是旋转数组。

|{counter:codes2503}
|{leetcode_base_url}/remove-linked-list-elements/[203. 移除链表元素^]
|{doc_base_url}/0203-remove-linked-list-elements.adoc[题解]
|✅ 快慢指针。看答案，一个指针也可以！而且代码更简单！

|{counter:codes2503}
|{leetcode_base_url}/maximum-length-of-repeated-subarray/[718. 最长重复子数组^]
|{doc_base_url}/0718-maximum-length-of-repeated-subarray.adoc[题解]
|❌ 动态规划。这里求的是公共子数组，只能在两个字符相等时，在上一个字符的基础上加 `1`，否则就应该设置为 `0`。不能取 `min{dp[i-1][j], dp[i][j-1]}`。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-subsequence/[1143. 最长公共子序列^]
|{doc_base_url}/1143-longest-common-subsequence.adoc[题解]
|✅ 动态规划。注意区分“子序列”和“子数组”的区别。

|{counter:codes2503}
|{leetcode_base_url}/minimum-size-subarray-sum/[209. 长度最小的子数组^]
|{doc_base_url}/0209-minimum-size-subarray-sum.adoc[题解]
|✅ 滑动窗口。没想到队列也能当滑动窗口。

|{counter:codes2503}
|{leetcode_base_url}/palindrome-partitioning/[131. Palindrome Partitioning^]
|{doc_base_url}/0131-palindrome-partitioning.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/accounts-merge/[721. 账户合并^]
|{doc_base_url}/0721-accounts-merge.adoc[题解]
|❌ 并查集。通过邮箱编号建立连接，而不是通过账户索引建立连接。

|{counter:codes2503}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|⭕️ 最初思路是排序。看答案，可以构建集合，然后“起点”（没有前一个数字）数字开始统计。

|{counter:codes2503}
|{leetcode_base_url}/design-linked-list/[707. 设计链表^]
|{doc_base_url}/0707-design-linked-list.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|❌ 单调栈，与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. Remove Duplicate Letters] 相同。知道用单调栈，但还是没写出来。

|{counter:codes2503}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/minimum-absolute-difference-in-bst/[530. 二叉搜索树的最小绝对差^]
|{doc_base_url}/0530-minimum-absolute-difference-in-bst.adoc[题解]
|✅ 二叉树中根遍历。

|{counter:codes2503}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|⭕️ 回溯。找出所有的高峰和山谷，然后对高峰做排列，计算各种排列与山谷的距离，取最小值即可。有模糊思路，看答案才写出代码。

|{counter:codes2503}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。要分情况处理窗口移动问题。

|{counter:codes2503}
|{leetcode_base_url}/longest-valid-parentheses/[32. 最长有效括号^]
|{doc_base_url}/0032-longest-valid-parentheses.adoc[题解]
|⭕️ 栈。使用栈记录左右括号的下标，匹配后标注“占位符”。最后，统计占位符中的数量，找出最大长度。

|{counter:codes2503}
|{leetcode_base_url}/search-a-2d-matrix/[74. 搜索二维矩阵^]
|{doc_base_url}/0074-search-a-2d-matrix.adoc[题解]
|✅ 二分查找。把矩阵按行“拼接”，然后二分查找，解法非常妙。

|{counter:codes2503}
|{leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^]
|{doc_base_url}/0084-largest-rectangle-in-histogram.adoc[题解]
|❌ 单调栈。一脸懵逼。哨兵技巧非常巧妙。

|{counter:codes2503}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string/[1047. 删除字符串中的所有相邻重复项^]
|{doc_base_url}/1047-remove-all-adjacent-duplicates-in-string.adoc[题解]
|⭕️ 栈。把 `StringBuilder` 当做栈来使用。将最后一个字符与当前字符比较，相等则删除最后一个字符，否则就添加。

|{counter:codes2503}
|{leetcode_base_url}/last-stone-weight-ii/[1049. 最后一块石头的重量 II^]
|{doc_base_url}/1049-last-stone-weight-ii.adoc[题解]
|❌ 动态规划，0/1 背包问题。一脸懵逼。

|{counter:codes2503}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|⭕️ 回溯。学习使用位操作来标注已用字符，计算未用字符。位操作真是太玄妙了！

|{counter:codes2503}
|{leetcode_base_url}/combination-sum/[39. 组合总和^]
|{doc_base_url}/0039-combination-sum.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-ii/[40. 组合总和 II^]
|{doc_base_url}/0040-combination-sum-ii.adoc[题解]
|✅ 回溯。注意同层剪枝的技巧。

|{counter:codes2503}
|{leetcode_base_url}/rotate-image/[48. 旋转图像^]
|{doc_base_url}/0048-rotate-image.adoc[题解]
|✅ 使用递归来推进循环。

|{counter:codes2503}
|{leetcode_base_url}/group-anagrams/[49. 字母异位词分组^]
|{doc_base_url}/0049-group-anagrams.adoc[题解]
|✅ 使用 `Map` 存字符和数量即可。

|{counter:codes2503}
|{leetcode_base_url}/subarray-sum-equals-k/[560. 和为 K 的子数组^]
|{doc_base_url}/0560-subarray-sum-equals-k.adoc[题解]
|✅ 前缀和。需要记录每一个和的出现次数。

|{counter:codes2503}
|{leetcode_base_url}/sqrtx/[69. x 的平方根^]
|{doc_base_url}/0069-sqrtx.adoc[题解]
|✅ 二分查找。使用一个单独变量来保存最后一个小于等于的中间值，那么即可直接获取答案。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-ii/[122. 买卖股票的最佳时机 II^]
|{doc_base_url}/0122-best-time-to-buy-and-sell-stock-ii.adoc[题解]
|✅ 有差价就买卖，见好就收。

|{counter:codes2503}
|{leetcode_base_url}/valid-palindrome/[125. 验证回文串^]
|{doc_base_url}/0125-valid-palindrome.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/single-number/[136. 只出现一次的数字^]
|{doc_base_url}/0136-single-number.adoc[题解]
|✅ 位运算。出现两次，则异或后为 `0`，所有数字异或，最后只剩下出现一次的数字。

|{counter:codes2503}
|{leetcode_base_url}/dota2-senate/[649. Dota2 参议院^]
|{doc_base_url}/0649-dota2-senate.adoc[题解]
|✅ 贪心算法。优先禁止最近的对方议员投票。不停循环，直到只留下一方议员。

|===

截止目前，本轮练习一共完成 {codes2503} 道题。
