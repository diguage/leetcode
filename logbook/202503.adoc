[#logbook-202503]
= 2025年03月 刷题日志
ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]


[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|⭕️ 递归解法非常妙！传一个参数，`next` 又 `next` 比较麻烦，传两个参数比较简单。

|{counter:codes2503}
|{leetcode_base_url}/find-first-and-last-position-of-element-in-sorted-array/[34. 在排序数组中查找元素的第一个和最后一个位置^]
|{doc_base_url}/0034-find-first-and-last-position-of-element-in-sorted-array.adoc[题解]
|✅ 思考清楚确定边界时，中间指针的移动方向即可迎刃而解。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点去处理有序部分，在有序部分内查找不到，则去另外一部分去查找。

|{counter:codes2503}
|{leetcode_base_url}/merge-intervals/[56. 合并区间^]
|{doc_base_url}/0056-merge-intervals.adoc[题解]
|✅ 对区间进行排序，然后快慢指针在当前数组上对其进行合并。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array-ii/[81. 搜索旋转排序数组 II^]
|{doc_base_url}/0081-search-in-rotated-sorted-array-ii.adoc[题解]
|✅ 关注有序区间，确定目标值在有序区间内，则在有序区间查找；反之，则在另外一部分内查找。另外，通过移动一个指针即可避开重复元素。

|{counter:codes2503}
|{leetcode_base_url}/two-sum/[1. 两数之和^]
|{doc_base_url}/0001-two-sum.adoc[题解]
|✅ 注意审题！返回的是数组下标。

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle/[141. 环形链表^]
|{doc_base_url}/0141-linked-list-cycle.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/happy-number/[202. 快乐数^]
|{doc_base_url}/0202-happy-number.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/minimum-window-substring/[76. 最小覆盖子串^]
|{doc_base_url}/0076-minimum-window-substring.adoc[题解]
|⭕️ 滑动窗口，一定注意细节的处理。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicate-letters/[316. 去除重复字母^]
|{doc_base_url}/0316-remove-duplicate-letters.adoc[题解]
|❌ 完全想不到单调栈！

|{counter:codes2503}
|{leetcode_base_url}/top-k-frequent-elements/[347. 前 K 个高频元素^]
|{doc_base_url}/0347-top-k-frequent-elements.adoc[题解]
|✅ Top K 问题，优先队列；桶排序

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|⭕️ 快速选择，想清楚边界情况！

|{counter:codes2503}
|{leetcode_base_url}/first-missing-positive/[41. 缺失的第一个正数^]
|{doc_base_url}/0041-first-missing-positive.adoc[题解]
|⭕️ 循环排序，看了答案，自己写出来了。

|{counter:codes2503}
|{leetcode_base_url}/find-median-from-data-stream/[295. 数据流的中位数^]
|{doc_base_url}/0295-find-median-from-data-stream.adoc[题解]
|⭕️ 对顶堆，思路理解，写代码却有很多问题。

|{counter:codes2503}
|{leetcode_base_url}/merge-k-sorted-lists/[23. 合并 K 个升序链表^]
|{doc_base_url}/0023-merge-k-sorted-lists.adoc[题解]
|✅ 多路归并

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-level-order-traversal/[102. 二叉树的层序遍历^]
|{doc_base_url}/0102-binary-tree-level-order-traversal.adoc[题解]
|✅ 广度优先搜索

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-maximum-path-sum/[124. 二叉树中的最大路径和^]
|{doc_base_url}/0124-binary-tree-maximum-path-sum.adoc[题解]
|⭕️ 深度优先搜索，注意处理负数情况

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-without-repeating-characters/[3. 无重复字符的最长子串^]
|{doc_base_url}/0003-longest-substring-without-repeating-characters.adoc[题解]
|✅ 滑动窗口

|{counter:codes2503}
|{leetcode_base_url}/lru-cache/[146. LRU 缓存^]
|{doc_base_url}/0146-lru-cache.adoc[题解]
|✅ 链表前后指针操作

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|✅ 两种解法：递归+迭代

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|✅ 快速选择

|{counter:codes2503}
|{leetcode_base_url}/reverse-nodes-in-k-group/[25. K 个一组翻转链表^]
|{doc_base_url}/0025-reverse-nodes-in-k-group.adoc[题解]
|✅ 分段递归反转，再拼接

|{counter:codes2503}
|{leetcode_base_url}/implement-trie-prefix-tree/[208. 实现 Trie (前缀树)^]
|{doc_base_url}/0208-implement-trie-prefix-tree.adoc[题解]
|✅ 前缀树，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/number-of-provinces/[547. 省份数量]
|{doc_base_url}/0547-number-of-provinces.adoc[题解]
|✅ 并查集，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 利用递归“降维”

|{counter:codes2503}
|{leetcode_base_url}/course-schedule/[207. 课程表^]
|{doc_base_url}/0207-course-schedule.adoc[题解]
|✅ 拓扑排序

|{counter:codes2503}
|{leetcode_base_url}/maximum-subarray/[53. 最大子数组和^]
|{doc_base_url}/0053-maximum-subarray.adoc[题解]
|⭕️ 动态规划。稀里糊涂就对了，还要对推演。另有更精妙的分治解法，抽空再尝试。

|{counter:codes2503}
|{leetcode_base_url}/merge-two-sorted-lists/[21. 合并两个有序链表^]
|{doc_base_url}/0021-merge-two-sorted-lists.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-substring/[5. 最长回文子串^]
|{doc_base_url}/0005-longest-palindromic-substring.adoc[题解]
|✅ 有更高效的马拉车算法，抽空可以尝试一下。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点关注有序部分，优先在有序部分查找，不在有序部分再去无序部分查找。注意判定有序部分的方法： `nums[0]` 与 `nums[mid]` 相比较，而不是 `nums[left]`（它的值会来回变）。

|{counter:codes2503}
|{leetcode_base_url}/number-of-islands/[200. 岛屿数量^]
|{doc_base_url}/0200-number-of-islands.adoc[题解]
|✅ 想尝试并查集，结果失败。还是沉岛大法好啊！

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/power-of-two/[231. 2 的幂^]
|{doc_base_url}/0231-power-of-two.adoc[题解]
|✅ 更巧妙的解法是位运算，如果 `n` 是 `2` 的幂，则二进制只有第一位是 `1`，减一则二进制都是 `1`，相与 `n & (n - 1)` 则为 `0`。

|{counter:codes2503}
|{leetcode_base_url}/merge-sorted-array/[88. 合并两个有序数组^]
|{doc_base_url}/0088-merge-sorted-array.adoc[题解]
|✅ `num1` 后面空着，则从后向前合并。

|{counter:codes2503}
|{leetcode_base_url}/powx-n/[50. Pow(x, n)^]
|{doc_base_url}/0050-powx-n.adoc[题解]
|✅ 递归很简单，抽空再思考一下非递归形式。

|{counter:codes2503}
|{leetcode_base_url}/sort-list/[148. 排序链表]
|{doc_base_url}/0148-sort-list.adoc[题解]
|✅ 分治

|{counter:codes2503}
|{leetcode_base_url}/ones-and-zeroes/[474. 一和零^]
|{doc_base_url}/0474-ones-and-zeroes.adoc[题解]
|❌ 动态规划，多维度“物品”就无从下手，还要多练。

|{counter:codes2503}
|{leetcode_base_url}/coin-change/[322. 零钱兑换]
|{doc_base_url}/0322-coin-change.adoc[题解]
|⭕️ 动态规划，完全背包问题

|{counter:codes2503}
|{leetcode_base_url}/subsets-ii/[90. 子集 II]
|{doc_base_url}/0090-subsets-ii.adoc[题解]
|⭕️ 子集，需要注意重复元素的处理。现在用 `Set` 记录已添加子集的方案还可以再优化。添加优化解法。

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 子集。注意对比子集模式在处理子集和排列时的不同：①子集直接在结果中添加新子集；②排列则是将结果中的元素出队，添加新元素后，再入队。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock/[121. 买卖股票的最佳时机^]
|{doc_base_url}/0121-best-time-to-buy-and-sell-stock.adoc[题解]
|✅ 遍历找最大差值

|{counter:codes2503}
|{leetcode_base_url}/lowest-common-ancestor-of-a-binary-tree/[236. 二叉树的最近公共祖先^]
|{doc_base_url}/0236-lowest-common-ancestor-of-a-binary-tree.adoc[题解]
|✅ 递归遍历查找目标节点，找到则返回，找不到则返回 `null`，当左右都不是 `null` 时，则当前节点即是最近公共祖先。

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list-ii/[92. 反转链表 II^]
|{doc_base_url}/0092-reverse-linked-list-ii.adoc[题解]
|✅ 链表反转

|{counter:codes2503}
|{leetcode_base_url}/find-the-index-of-the-first-occurrence-in-a-string/[28. 找出字符串中第一个匹配项的下标]
|{doc_base_url}/0028-find-the-index-of-the-first-occurrence-in-a-string.adoc[题解]
|✅ 暴力破解。更有的解法是 KMP 算法、Boyer-Moore 算法、Sunday 算法等算法。

|{counter:codes2503}
|{leetcode_base_url}/spiral-matrix/[54. Spiral Matrix^]
|{doc_base_url}/0054-spiral-matrix.adoc[题解]
|✅ 使用递归来推进层级。注意处理细节。另外，在“上”和“右”能覆盖“全部”（比如一行多列或者多行一列）时，才能在“下”之前根据长度返回。尝试了每段“读取”只剩一个的方案，不行，有很多意外情况要处理。

|{counter:codes2503}
|{leetcode_base_url}/add-strings/[415. 字符串相加^]
|{doc_base_url}/0415-add-strings.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/reorder-list/[143. Reorder List^]
|{doc_base_url}/0143-reorder-list.adoc[题解]
|✅ 双指针+链表反正+链表合并

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle-ii/[142. 环形链表 II^]
|{doc_base_url}/0142-linked-list-cycle-ii.adoc[题解]
|✅ 双指针+数学

|{counter:codes2503}
|{leetcode_base_url}/remove-nth-node-from-end-of-list/[19. 删除链表的倒数第 N 个结点^]
|{doc_base_url}/0019-remove-nth-node-from-end-of-list.adoc[题解]
|✅ 双指针+虚拟头节点。使用虚拟头结点会省事好多。

|{counter:codes2503}
|{leetcode_base_url}/restore-ip-addresses/[93. 复原 IP 地址^]
|{doc_base_url}/0093-restore-ip-addresses.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/n-th-tribonacci-number/[1137. 第 N 个泰波那契数^]
|{doc_base_url}/1137-n-th-tribonacci-number.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber/[198. 打家劫舍^]
|{doc_base_url}/0198-house-robber.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-ii/[213. 打家劫舍 II^]
|{doc_base_url}/0213-house-robber-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iii/[337. 打家劫舍 III^]
|{doc_base_url}/0337-house-robber-iii.adoc[题解]
|✅ 动态规划+树 = 树形动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iv/[2560. 打家劫舍 IV^]
|{doc_base_url}/2560-house-robber-iv.adoc[题解]
|❌ 看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/delete-and-earn/[740. 删除并获得点数^]
|{doc_base_url}/0740-delete-and-earn.adoc[题解]
|❌ 把题目理解错了。处理后就是最简单的打家劫舍问题。

|{counter:codes2503}
|{leetcode_base_url}/unique-paths/[62. 不同路径^]
|{doc_base_url}/0062-unique-paths.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-ii/[63. 不同路径 II^]
|{doc_base_url}/0063-unique-paths-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-iii/[980. 不同路径 III^]
|{doc_base_url}/0980-unique-paths-iii.adoc[题解]
|❌ 明知是回溯，但在处理当前节点时，总把当前和下一步混在一起。有思路，没写出代码。

|{counter:codes2503}
|{leetcode_base_url}/minimum-path-sum/[64. 最小路径和^]
|{doc_base_url}/0064-minimum-path-sum.adoc[题解]
|✅ 动态规划。直接在原有矩阵上操作即可。

|{counter:codes2503}
|{leetcode_base_url}/triangle/[120. 三角形最小路径和^]
|{doc_base_url}/0120-triangle.adoc[题解]
|✅ 动态规划。从底向上比从上向底效率更高。

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum/[931. 下降路径最小和^]
|{doc_base_url}/0931-minimum-falling-path-sum.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum-ii/[1289. 下降路径最小和  II^]
|{doc_base_url}/1289-minimum-falling-path-sum-ii.adoc[题解]
|⭕️ 动态规划。题目理解错误。

|{counter:codes2503}
|{leetcode_base_url}/maximal-square/[221. 最大正方形^]
|{doc_base_url}/0221-maximal-square.adoc[题解]
|✅ 动态规划。直接将结果存储在参数矩阵上。如果正方形想扩大，则左边，左上和上面三个都是正方形时才可以，可以直接去这三者中的最小值。

|{counter:codes2503}
|{leetcode_base_url}/word-break/[139. 单词拆分^]
|{doc_base_url}/0139-word-break.adoc[题解]
|⭕️ 回溯+备忘录。首先想到的是回溯，但是超时（通过34/47的测试用例）。参考别人题解后，得到启发，加上备忘录通过。参考答案写出了动态规划的解法。*思考如何从基于回溯+备忘录转变为动态规划？*

|{counter:codes2503}
|{leetcode_base_url}/word-break-ii/[140. 单词拆分 II^]
|{doc_base_url}/0140-word-break-ii.adoc[题解]
|✅ 回溯。没想到从 `LinkedList` 切换到 `ArrayList`，内存占用就大幅下降 43.77% → 91.82%。没有使用备忘录耗时已经击败了 98.49%。

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-subsequence/[516. 最长回文子序列^]
|{doc_base_url}/0516-longest-palindromic-subsequence.adoc[题解]
|❌ 动态规划。相当于在“结尾”中寻找回文子串。从一维字符串字符坐标去看转移方程，会更加清楚明了。

|{counter:codes2503}
|{leetcode_base_url}/container-with-most-water/[11. 盛最多水的容器^]
|{doc_base_url}/0011-container-with-most-water.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/remove-element/[27. 移除元素^]
|{doc_base_url}/0027-remove-element.adoc[题解]
|✅ 快慢指针。慢指针记录满足条件的长度，快指针指向需要处理的元素。

|{counter:codes2503}
|{leetcode_base_url}/trapping-rain-water/[42. 接雨水^]
|{doc_base_url}/0042-trapping-rain-water.adoc[题解]
|❌ 使用单调栈没写出来。使用单调栈，需 `h × w`，不能只看头顶的容量。使用左右双指针夹逼代码更简单，只需要计算头顶的容量即可。

|{counter:codes2503}
|{leetcode_base_url}/edit-distance/[72. 编辑距离^]
|{doc_base_url}/0072-edit-distance.adoc[题解]
|✅ 动态规划。思考如何进一步优化成一维数组？

|{counter:codes2503}
|{leetcode_base_url}/maximum-width-of-binary-tree/[662. 二叉树最大宽度^]
|{doc_base_url}/0662-maximum-width-of-binary-tree.adoc[题解]
|⭕️ 添加虚拟节点的做法超时。看答案给节点加编号通过。

|{counter:codes2503}
|{leetcode_base_url}/next-permutation/[31. 下一个排列^]
|{doc_base_url}/0031-next-permutation.adoc[题解]
|❌ 明白大概意思，思路不够条理，写不出代码。

|{counter:codes2503}
|{leetcode_base_url}/rotate-array/[189. 轮转数组^]
|{doc_base_url}/0189-rotate-array.adoc[题解]
|❌ 题目理解错误，是轮转数组，不是旋转数组。

|{counter:codes2503}
|{leetcode_base_url}/remove-linked-list-elements/[203. 移除链表元素^]
|{doc_base_url}/0203-remove-linked-list-elements.adoc[题解]
|✅ 快慢指针。看答案，一个指针也可以！而且代码更简单！

|{counter:codes2503}
|{leetcode_base_url}/maximum-length-of-repeated-subarray/[718. 最长重复子数组^]
|{doc_base_url}/0718-maximum-length-of-repeated-subarray.adoc[题解]
|❌ 动态规划。这里求的是公共子数组，只能在两个字符相等时，在上一个字符的基础上加 `1`，否则就应该设置为 `0`。不能取 `min{dp[i-1][j], dp[i][j-1]}`。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-subsequence/[1143. 最长公共子序列^]
|{doc_base_url}/1143-longest-common-subsequence.adoc[题解]
|✅ 动态规划。注意区分“子序列”和“子数组”的区别。

|{counter:codes2503}
|{leetcode_base_url}/minimum-size-subarray-sum/[209. 长度最小的子数组^]
|{doc_base_url}/0209-minimum-size-subarray-sum.adoc[题解]
|✅ 滑动窗口。没想到队列也能当滑动窗口。

|{counter:codes2503}
|{leetcode_base_url}/palindrome-partitioning/[131. Palindrome Partitioning^]
|{doc_base_url}/0131-palindrome-partitioning.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/accounts-merge/[721. 账户合并^]
|{doc_base_url}/0721-accounts-merge.adoc[题解]
|❌ 并查集。通过邮箱编号建立连接，而不是通过账户索引建立连接。

|{counter:codes2503}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|⭕️ 最初思路是排序。看答案，可以构建集合，然后“起点”（没有前一个数字）数字开始统计。

|{counter:codes2503}
|{leetcode_base_url}/design-linked-list/[707. 设计链表^]
|{doc_base_url}/0707-design-linked-list.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|❌ 单调栈，与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. Remove Duplicate Letters] 相同。知道用单调栈，但还是没写出来。

|{counter:codes2503}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/minimum-absolute-difference-in-bst/[530. 二叉搜索树的最小绝对差^]
|{doc_base_url}/0530-minimum-absolute-difference-in-bst.adoc[题解]
|✅ 二叉树中根遍历。

|{counter:codes2503}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|⭕️ 回溯。找出所有的高峰和山谷，然后对高峰做排列，计算各种排列与山谷的距离，取最小值即可。有模糊思路，看答案才写出代码。

|{counter:codes2503}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。要分情况处理窗口移动问题。

|{counter:codes2503}
|{leetcode_base_url}/longest-valid-parentheses/[32. 最长有效括号^]
|{doc_base_url}/0032-longest-valid-parentheses.adoc[题解]
|⭕️ 栈。使用栈记录左右括号的下标，匹配后标注“占位符”。最后，统计占位符中的数量，找出最大长度。

|{counter:codes2503}
|{leetcode_base_url}/search-a-2d-matrix/[74. 搜索二维矩阵^]
|{doc_base_url}/0074-search-a-2d-matrix.adoc[题解]
|✅ 二分查找。把矩阵按行“拼接”，然后二分查找，解法非常妙。

|{counter:codes2503}
|{leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^]
|{doc_base_url}/0084-largest-rectangle-in-histogram.adoc[题解]
|❌ 单调栈。一脸懵逼。哨兵技巧非常巧妙。

|{counter:codes2503}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string/[1047. 删除字符串中的所有相邻重复项^]
|{doc_base_url}/1047-remove-all-adjacent-duplicates-in-string.adoc[题解]
|⭕️ 栈。把 `StringBuilder` 当做栈来使用。将最后一个字符与当前字符比较，相等则删除最后一个字符，否则就添加。

|{counter:codes2503}
|{leetcode_base_url}/last-stone-weight-ii/[1049. 最后一块石头的重量 II^]
|{doc_base_url}/1049-last-stone-weight-ii.adoc[题解]
|❌ 动态规划，0/1 背包问题。一脸懵逼。

|{counter:codes2503}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|⭕️ 回溯。学习使用位操作来标注已用字符，计算未用字符。位操作真是太玄妙了！

|{counter:codes2503}
|{leetcode_base_url}/combination-sum/[39. 组合总和^]
|{doc_base_url}/0039-combination-sum.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-ii/[40. 组合总和 II^]
|{doc_base_url}/0040-combination-sum-ii.adoc[题解]
|✅ 回溯。注意同层剪枝的技巧。

|{counter:codes2503}
|{leetcode_base_url}/rotate-image/[48. 旋转图像^]
|{doc_base_url}/0048-rotate-image.adoc[题解]
|✅ 使用递归来推进循环。

|{counter:codes2503}
|{leetcode_base_url}/group-anagrams/[49. 字母异位词分组^]
|{doc_base_url}/0049-group-anagrams.adoc[题解]
|✅ 使用 `Map` 存字符和数量即可。

|{counter:codes2503}
|{leetcode_base_url}/subarray-sum-equals-k/[560. 和为 K 的子数组^]
|{doc_base_url}/0560-subarray-sum-equals-k.adoc[题解]
|✅ 前缀和。需要记录每一个和的出现次数。

|{counter:codes2503}
|{leetcode_base_url}/sqrtx/[69. x 的平方根^]
|{doc_base_url}/0069-sqrtx.adoc[题解]
|✅ 二分查找。使用一个单独变量来保存最后一个小于等于的中间值，那么即可直接获取答案。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-ii/[122. 买卖股票的最佳时机 II^]
|{doc_base_url}/0122-best-time-to-buy-and-sell-stock-ii.adoc[题解]
|✅ 有差价就买卖，见好就收。

|{counter:codes2503}
|{leetcode_base_url}/valid-palindrome/[125. 验证回文串^]
|{doc_base_url}/0125-valid-palindrome.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/single-number/[136. 只出现一次的数字^]
|{doc_base_url}/0136-single-number.adoc[题解]
|✅ 位运算。出现两次，则异或后为 `0`，所有数字异或，最后只剩下出现一次的数字。

|{counter:codes2503}
|{leetcode_base_url}/dota2-senate/[649. Dota2 参议院^]
|{doc_base_url}/0649-dota2-senate.adoc[题解]
|✅ 贪心算法。优先禁止最近的对方议员投票。不停循环，直到只留下一方议员。

|{counter:codes2503}
|{leetcode_base_url}/maximum-swap/[670. 最大交换^]
|{doc_base_url}/0670-maximum-swap.adoc[题解]
|✅ 贪心算法。最高位尽可能跟后面的最大数字进行交换。

|{counter:codes2503}
|{leetcode_base_url}/two-sum-ii-input-array-is-sorted/[167. 两数之和 II - 输入有序数组^]
|{doc_base_url}/0167-two-sum-ii-input-array-is-sorted.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/degree-of-an-array/[697. 数组的度^]
|{doc_base_url}/0697-degree-of-an-array.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/design-add-and-search-words-data-structure/[211. 添加与搜索单词 - 数据结构设计]
|{doc_base_url}/0211-design-add-and-search-words-data-structure.adoc[题解]
|✅ 前缀树。需要处理通配符的情况，尤其要注意结尾字符的处理。

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-iii/[216. 组合总和 III^]
|{doc_base_url}/0216-combination-sum-iii.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/basic-calculator/[224. 基本计算器^]
|{doc_base_url}/0224-basic-calculator.adoc[题解]
|❌ 使用双栈来分别存放数字和操作符。

|{counter:codes2503}
|{leetcode_base_url}/sliding-window-maximum/[239. 滑动窗口最大值^]
|{doc_base_url}/0239-sliding-window-maximum.adoc[题解]
|✅ 单调栈。有很多细节需要考虑。

|{counter:codes2503}
|{leetcode_base_url}/single-number-iii/[260. 只出现一次的数字 III^]
|{doc_base_url}/0260-single-number-iii.adoc[题解]
|⭕️ 在 {doc_base_url}/0136-single-number.adoc[136. 只出现一次的数字] 基础上，做了进一步延伸。需要先根据所有数异或值的最后一位 `1`，将数字分为两部分，再分别做异或。

|{counter:codes2503}
|{leetcode_base_url}/single-number-ii/[137. 只出现一次的数字 II^]
|{doc_base_url}/0137-single-number-ii.adoc[题解]
|❌ 位运算。按位统计 `1` 出现的次数，取余留下来的则是 只出现一次的数字所拥有的 `1`，然后再做运算恢复成原始数字即可。

|{counter:codes2503}
|{leetcode_base_url}/distinct-subsequences/[115. 不同的子序列^]
|{doc_base_url}/0115-distinct-subsequences.adoc[题解]
|❌ 动态规划。

|{counter:codes2503}
|{leetcode_base_url}/number-of-good-leaf-nodes-pairs/[1530. 好叶子节点对的数量^]
|{doc_base_url}/1530-number-of-good-leaf-nodes-pairs.adoc[题解]
|⭕️ 还有瑕疵，还需要继续优化。

|{counter:codes2503}
|{leetcode_base_url}/remove-zero-sum-consecutive-nodes-from-linked-list/[1171. 从链表中删去总和值为零的连续节点^]
|{doc_base_url}/1171-remove-zero-sum-consecutive-nodes-from-linked-list.adoc[题解]
|❌ 前缀和。想到了前缀和，但是没想到可以利用中间和为 `0`，直接跳过这部分节点。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-iii/[123. 买卖股票的最佳时机 III^]
|{doc_base_url}/0123-best-time-to-buy-and-sell-stock-iii.adoc[题解]
|❌ 动态规划。思路还需要多揣摩和思考。

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-right-side-view/[199. 二叉树的右视图^]
|{doc_base_url}/0199-binary-tree-right-side-view.adoc[题解]
|✅ 深度优先遍历。按照 `<level, node>` 的格式，把每个节点都放到 `Map` 里，因为是先左后右，所以，每层最后只剩下了最右边的元素。

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-moves-in-a-grid/[2684. 矩阵中移动的最大次数^]
|{doc_base_url}/2684-maximum-number-of-moves-in-a-grid.adoc[题解]
|✅ 动态规划。也可以使用深度优先搜索的解法，使用深度优先搜索时，需要把处理过的节点值设置为 `0`，防止重新判断，加快处理速度。

|{counter:codes2503}
|{leetcode_base_url}/cheapest-flights-within-k-stops/[787. K 站中转内最便宜的航班^]
|{doc_base_url}/0787-cheapest-flights-within-k-stops.adoc[题解]
|⭕️ 深度优先搜索通过 48 / 56 个测试用例。使用带备忘录的深度优先搜索顺利通过。带备忘录的深度优先搜索，也可以优化成动态规划。

|{counter:codes2503}
|{leetcode_base_url}/valid-tic-tac-toe-state/[794. 有效的井字游戏^]
|{doc_base_url}/0794-valid-tic-tac-toe-state.adoc[题解]
|✅ 总结提炼判断规则。

|{counter:codes2503}
|{leetcode_base_url}/harshad-number/[3099. 哈沙德数^]
|{doc_base_url}/3099-harshad-number.adoc[题解]
|✅ 数学计算

|{counter:codes2503}
|{leetcode_base_url}/longest-increasing-subsequence/[300. 最长递增子序列^]
|{doc_base_url}/0300-longest-increasing-subsequence.adoc[题解]
|❌ 动态规划。动态规划+二分查找的解法一脸懵逼，看答案都懵逼！

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-preorder-traversal/[144. 二叉树的前序遍历^]
|{doc_base_url}/0144-binary-tree-preorder-traversal.adoc[题解]
|✅ 树的 Morris 遍历

|{counter:codes2503}
|{leetcode_base_url}/maximum-prime-difference/[3115. 质数的最大距离^]
|{doc_base_url}/3115-maximum-prime-difference.adoc[题解]
|✅ 质数判断

|{counter:codes2503}
|{leetcode_base_url}/design-hashset/[705. 设计哈希集合^]
|{doc_base_url}/0705-design-hashset.adoc[题解]
|✅ 使用开放地址法解决哈希冲突。

|{counter:codes2503}
|{leetcode_base_url}/shortest-string-that-contains-three-strings/[2800. 包含三个字符串的最短字符串^]
|{doc_base_url}/2800-shortest-string-that-contains-three-strings.adoc[题解]
|❌ 先求三个字符串的全排列，然后合并（合并时注意处理首尾相同子串，减少合并字符串的长度），在这些合并后的字符串中选择最短，字典排序最小的字符串。

|{counter:codes2503}
|{leetcode_base_url}/count-number-of-ways-to-place-houses/[2320. 统计放置房子的方式数^]
|{doc_base_url}/2320-count-number-of-ways-to-place-houses.adoc[题解]
|❌ 先只考虑一边的情况，再组合两边的情况。只考虑一边的情况，就是一个斐波那契数列： stem:[f(i) = f(i-1) + f(i-2)]。

|{counter:codes2503}
|{leetcode_base_url}/minimum-number-of-operations-to-move-all-balls-to-each-box/[1769. 移动所有球到每个盒子所需的最小操作数^]
|{doc_base_url}/1769-minimum-number-of-operations-to-move-all-balls-to-each-box.adoc[题解]
|✅ 最简单的解法双重循环。取巧的解法是，利用“前缀和”的思路，分别计算当前节点左右两侧的操作次数，然后再相加。

|{counter:codes2503}
|{leetcode_base_url}/intersection-of-two-arrays-ii/[350. 两个数组的交集 II^]
|{doc_base_url}/0350-intersection-of-two-arrays-ii.adoc[题解]
|✅ 最初思路是对两个数组统计次数。其实只需要对一个数组统计次数，另外一个数组遍历时就可以求交集了。

|{counter:codes2503}
|{leetcode_base_url}/is-subsequence/[392. 判断子序列^]
|{doc_base_url}/0392-is-subsequence.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/longest-palindrome/[409. 最长回文串^]
|{doc_base_url}/0409-longest-palindrome.adoc[题解]
|✅ 回文

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-of-all-vowels-in-order/[1839. 所有元音按顺序排布的最长子字符串^]
|{doc_base_url}/1839-longest-substring-of-all-vowels-in-order.adoc[题解]
|✅ 滑动窗口。题目不难，只是处理边界条件麻烦。另外，也有取巧解法，可以探索一下。

|{counter:codes2503}
|{leetcode_base_url}/maximum-sum-circular-subarray/[918. 环形子数组的最大和^]
|{doc_base_url}/0918-maximum-sum-circular-subarray.adoc[题解]
|❌ 理解错题目了。前大，中小，后大，这类子数组也可以产生更多的子数组和。另有“取反”和单调栈解法。

|{counter:codes2503}
|{leetcode_base_url}/maximum-students-taking-exam/[1349. 参加考试的最大学生数^]
|{doc_base_url}/1349-maximum-students-taking-exam.adoc[题解]
|❌ 回溯解法通过 50 / 57 个测试用例。动态规划解法太难了！

|{counter:codes2503}
|{leetcode_base_url}/rotting-oranges/[994. 腐烂的橘子^]
|{doc_base_url}/0994-rotting-oranges.adoc[题解]
|✅ 腐烂加剧+传染。广度优先遍历的解法也挺有意思。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-prefix/[14. 最长公共前缀^]
|{doc_base_url}/0014-longest-common-prefix.adoc[题解]
|✅ 解法很多，可以很好地开阔思路！

|{counter:codes2503}
|{leetcode_base_url}/generate-parentheses/[22. 括号生成^]
|{doc_base_url}/0022-generate-parentheses.adoc[题解]
|✅ 回溯。也可以去掉回溯过程，使用深度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/swap-nodes-in-pairs/[24. 两两交换链表中的节点^]
|{doc_base_url}/0024-swap-nodes-in-pairs.adoc[题解]
|✅ 链表。增加虚拟节点，极大简化代码。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-array/[26. 删除有序数组中的重复项^]
|{doc_base_url}/0026-remove-duplicates-from-sorted-array.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/jump-game-ii/[45. 跳跃游戏 II^]
|{doc_base_url}/0045-jump-game-ii.adoc[题解]
|✅ 贪心算法。也可以动态规划。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-array-ii/[80. 删除有序数组中的重复项 II^]
|{doc_base_url}/0080-remove-duplicates-from-sorted-array-ii.adoc[题解]
|✅ 双指针，同时需要记录每个元素的次数，相同元素只复制两个。

|{counter:codes2503}
|{leetcode_base_url}/jump-game/[55. 跳跃游戏^]
|{doc_base_url}/0055-jump-game.adoc[题解]
|✅ 贪心算法。没想到这就是贪心？

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-list-ii/[82. 删除排序链表中的重复元素 II^]
|{doc_base_url}/0082-remove-duplicates-from-sorted-list-ii.adoc[题解]
|✅ 快慢指针。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-list/[83. 删除排序链表中的重复元素^]
|{doc_base_url}/0083-remove-duplicates-from-sorted-list.adoc[题解]
|✅ 链表操作

|{counter:codes2503}
|{leetcode_base_url}/decode-ways/[91. 解码方法^]
|{doc_base_url}/0091-decode-ways.adoc[题解]
|❌ 动态规划。递推公式还要仔细推敲。

|{counter:codes2503}
|{leetcode_base_url}/check-if-matrix-is-x-matrix/[2319. 判断矩阵是否是一个 X 矩阵^]
|{doc_base_url}/2319-check-if-matrix-is-x-matrix.adoc[题解]
|✅ 遍历对角线设置成负值，检查其他元素，发现有大于 `0` 的则不成矩阵。

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-balloons/[1189. “气球” 的最大数量^]
|{doc_base_url}/1189-maximum-number-of-balloons.adoc[题解]
|✅ 哈希

|{counter:codes2503}
|{leetcode_base_url}/minimum-rectangles-to-cover-points/[3111. 覆盖所有点的最少矩形数目^]
|{doc_base_url}/3111-minimum-rectangles-to-cover-points.adoc[题解]
|✅ 贪心。从左边界开始，尽可能多占用横轴。宽度耗尽，则从下一个点开始。

|{counter:codes2503}
|{leetcode_base_url}/minimum-difference-between-largest-and-smallest-value-in-three-moves/[1509. 三次操作后最大值与最小值的最小差^]
|{doc_base_url}/1509-minimum-difference-between-largest-and-smallest-value-in-three-moves.adoc[题解]
|✅ 贪心。转变一下题目就是要求如何缩短最大值和最小值直接的差值。看官方题解，可以直接求 stem:[a(n - 4 + i) - a(i)] 的最小值。

|{counter:codes2503}
|{leetcode_base_url}/number-of-students-unable-to-eat-lunch/[1700. 无法吃午餐的学生数量^]
|{doc_base_url}/1700-number-of-students-unable-to-eat-lunch.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/pseudo-palindromic-paths-in-a-binary-tree/[1457. 二叉树中的伪回文路径^]
|{doc_base_url}/1457-pseudo-palindromic-paths-in-a-binary-tree.adoc[题解]
|✅ 回溯，深度优先遍历，到叶子节点判断是否可以组成回文。

|{counter:codes2503}
|{leetcode_base_url}/html-entity-parser/[1410. HTML 实体解析器^]
|{doc_base_url}/1410-html-entity-parser.adoc[题解]
|✅ 哈希 + 字符串

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-coins-you-can-get/[1561. 你可以获得的最大硬币数目^]
|{doc_base_url}/1561-maximum-number-of-coins-you-can-get.adoc[题解]
|✅ 贪心。每次去第二大的数字即可。

|{counter:codes2503}
|{leetcode_base_url}/delete-leaves-with-a-given-value/[1325. 删除给定值的叶子节点^]
|{doc_base_url}/1325-delete-leaves-with-a-given-value.adoc[题解]
|✅ 深度优先遍历，在“后序”中做业务处理。

|{counter:codes2503}
|{leetcode_base_url}/minimum-cost-to-move-chips-to-the-same-position/[1217. 玩筹码]
|{doc_base_url}/1217-minimum-cost-to-move-chips-to-the-same-position.adoc[题解]
|❌ 题目理解错误！`position[i]` 中的数字是筹码的位置。题目意思是奇数到奇数和偶数到偶数免费，但是紧挨的两个数字移动收费，所以，统计奇偶数的个数，看哪个小就移动哪个。

|{counter:codes2503}
|{leetcode_base_url}/clumsy-factorial/[1006. 笨阶乘^]
|{doc_base_url}/1006-clumsy-factorial.adoc[题解]
|✅ 栈。代码写出来了，但是好烂！

|{counter:codes2503}
|{leetcode_base_url}/keys-and-rooms/[841. 钥匙和房间^]
|{doc_base_url}/0841-keys-and-rooms.adoc[题解]
|✅ 深度优先遍历或广度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/find-and-replace-pattern/[890. 查找和替换模式^]
|{doc_base_url}/0890-find-and-replace-pattern.adoc[题解]
|✅ 映射。建立一个字母映射，并且每个字母只能有一种映射关系。否则就不匹配。

|{counter:codes2503}
|{leetcode_base_url}/grumpy-bookstore-owner/[1052. 爱生气的书店老板^]
|{doc_base_url}/1052-grumpy-bookstore-owner.adoc[题解]
|✅ 先计算没有生气而满意的总数，再计算因为老板憋气而满意的增量用户。

|{counter:codes2503}
|{leetcode_base_url}/moving-stones-until-consecutive/[1033. 移动石子直到连续^]
|{doc_base_url}/1033-moving-stones-until-consecutive.adoc[题解]
|✅ 分类讨论

|{counter:codes2503}
|{leetcode_base_url}/number-of-enclaves/[1020. 飞地的数量^]
|{doc_base_url}/1020-number-of-enclaves.adoc[题解]
|✅ 深度优先遍历。有机会尝试一下广度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/sum-of-root-to-leaf-binary-numbers/[1022. 从根到叶的二进制数之和^]
|{doc_base_url}/1022-sum-of-root-to-leaf-binary-numbers.adoc[题解]
|✅ 深度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/partition-array-into-disjoint-intervals/[915. 分割数组^]
|{doc_base_url}/0915-partition-array-into-disjoint-intervals.adoc[题解]
|✅ 两遍遍历。有题解可以不到一遍遍历即可解决问题。

|{counter:codes2503}
|{leetcode_base_url}/sort-integers-by-the-power-value/[1387. 将整数按权重排序^]
|{doc_base_url}/1387-sort-integers-by-the-power-value.adoc[题解]
|✅ 先计算每个数字的权重，再进行比较：使用集合存储下标，通过下标找到对应的权重。计算权重时，可以递归，也可以直接循环。使用递归时，可以使用备忘录把已经计算的值存储起来，防止重复计算。

|{counter:codes2503}
|{leetcode_base_url}/path-crossing/[1496. 判断路径是否相交^]
|{doc_base_url}/1496-path-crossing.adoc[题解]
|✅ 想找个巧办法，结果失败！还是用记录轨迹的办法搞定了。

|{counter:codes2503}
|{leetcode_base_url}/delete-nodes-and-return-forest/[1110. 删点成林^]
|{doc_base_url}/1110-delete-nodes-and-return-forest.adoc[题解]
|✅ 深度优先遍历，把父节点传到递归参数里，同时标注一下是左子树还是右子树。

|{counter:codes2503}
|{leetcode_base_url}/count-triplets-that-can-form-two-arrays-of-equal-xor/[1442. 形成两个异或相等数组的三元组数目^]
|{doc_base_url}/1442-count-triplets-that-can-form-two-arrays-of-equal-xor.adoc[题解]
|⭕️ 前缀和。使用官方题解中的异或前缀和解法啦。数学知识还是得补啊！原来的思路是回溯，通过 46 / 47 测试用例。使用回溯应该对，但是加上备忘录后，还是有一个测试用例没通过。（看一个题解，原始解法就是暴力法。是对的。）

|{counter:codes2503}
|{leetcode_base_url}/construct-k-palindrome-strings/[1400. 构造 K 个回文字符串^]
|{doc_base_url}/1400-construct-k-palindrome-strings.adoc[题解]
|⭕️ 统计奇数字母个数，如果个数超过 `k` 肯定就不满足了。自己的思考已经解决答案了。可惜不够确定，还是参考答案了。

|{counter:codes2503}
|{leetcode_base_url}/rle-iterator/[900. RLE 迭代器^]
|{doc_base_url}/0900-rle-iterator.adoc[题解]
|✅ 使用属性 `index` 记录 `next` 到位置，剩下就是在 `encoding` 的偶数下标上做减法。

|{counter:codes2503}
|{leetcode_base_url}/closest-divisors/[1362. 最接近的因数^]
|{doc_base_url}/1362-closest-divisors.adoc[题解]
|✅ 我的解法是从两边向中间挤压；更优解是找到平方根，然后向外开。

|{counter:codes2503}
|{leetcode_base_url}/smallest-subtree-with-all-the-deepest-nodes/[865. 具有所有最深节点的最小子树^]
|{doc_base_url}/0865-smallest-subtree-with-all-the-deepest-nodes.adoc[题解]
|✅ 深度优先遍历，递归，在“后序”阶段处理业务逻辑。

|{counter:codes2503}
|{leetcode_base_url}/camelcase-matching/[1023. 驼峰式匹配^]
|{doc_base_url}/1023-camelcase-matching.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/balance-a-binary-search-tree/[1382. 将二叉搜索树变平衡^]
|{doc_base_url}/1382-balance-a-binary-search-tree.adoc[题解]
|✅ 二叉搜索树，先中序遍历拿到所有节点，然后递归构造平衡二叉搜索树。

|{counter:codes2503}
|{leetcode_base_url}/minimum-domino-rotations-for-equal-row/[1007. 行相等的最少多米诺旋转^]
|{doc_base_url}/1007-minimum-domino-rotations-for-equal-row.adoc[题解]
|✅ 统计每个数字的下标，然后逐个检查每个数字的下标集合是否能完整覆盖原始数字的全部下标。更优解：判断是否可以都变成 `tops[0]` 或者 `bottoms[0]`。

|{counter:codes2503}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string-ii/[1209. 删除字符串中的所有相邻重复项 II^]
|{doc_base_url}/1209-remove-all-adjacent-duplicates-in-string-ii.adoc[题解]
|✅ 暴力解法：对重复的相邻字母计数，当计数达到 k 时将其删除。重复此操作，直到没有删除的字符为止。通过 19 / 21 个测试用例。更优解：把当前字符的次数存下来，下一个字符就可以在当前字符基础上做处理，省去重复计算。官方题解提供了多种解法，非常优秀！

|{counter:codes2503}
|{leetcode_base_url}/interval-list-intersections/[986. 区间列表的交集^]
|{doc_base_url}/0986-interval-list-intersections.adoc[题解]
|✅ 双指针。先排除两种没有交集的情况，剩下四种有交集的情况，左边选两个里面最大的，右边选两个里面最小的。哪个小，向右移动哪个的指针。

|{counter:codes2503}
|{leetcode_base_url}/path-in-zigzag-labelled-binary-tree/[1104. 二叉树寻路^]
|{doc_base_url}/1104-path-in-zigzag-labelled-binary-tree.adoc[题解]
|✅ 找到每一层的左右端点的值，确认所求数值在本层中的下标（从 `1` 开始），开始循环，每次循环下标都除以 `2` 再向上取整。这样就可以获取每个数值对应的节点。

|{counter:codes2503}
|{leetcode_base_url}/flatten-binary-tree-to-linked-list/[114. Flatten Binary Tree to Linked List^]
|{doc_base_url}/0114-flatten-binary-tree-to-linked-list.adoc[题解]
|✅ 右子树肯定比左子树的最大值还要大，所以，可以直接把右子树直接挂在左子树的右子树上。然后，把左子树挂在右子树的指针上，当前节点向右移动一下，继续上面的操作。

|{counter:codes2503}
|{leetcode_base_url}/populating-next-right-pointers-in-each-node-ii/[117. 填充每个节点的下一个右侧节点指针 II^]
|{doc_base_url}/0117-populating-next-right-pointers-in-each-node-ii.adoc[题解]
|✅ 在上一层构建下一层的连接。由于存在空节点，要在运动中找“最左节点”和“前一个节点”。

|{counter:codes2503}
|{leetcode_base_url}/clone-graph/[133. 克隆图^]
|{doc_base_url}/0133-clone-graph.adoc[题解]
|✅ DFS+哈希。本想通过修改原始节点值，省去哈希，但是由于有环，存在循环依赖，没办法省掉。

|{counter:codes2503}
|{leetcode_base_url}/gas-station/[134. Gas Station^]
|{doc_base_url}/0134-gas-station.adoc[题解]
|✅ 看其他题解是贪心算法。我的解法感觉是遍历，不知道算不算贪心。

|{counter:codes2503}
|{leetcode_base_url}/candy/[135. 分发糖果^]
|{doc_base_url}/0135-candy.adoc[题解]
|⭕️ 初步设想是一次遍历。后来看题解，可以从两端遍历，再就和。这样可以省去很多判断。

|{counter:codes2503}
|{leetcode_base_url}/max-points-on-a-line/[149. 直线上最多的点数^]
|{doc_base_url}/0149-max-points-on-a-line.adoc[题解]
|⭕️ 通过计算 stem:[(y_1 - y_2) / (x_1 - x_2) = (y_2 - y_3)/(x_2 - x_3)] 即可确定三个点是否在同一个直线上。

|{counter:codes2503}
|{leetcode_base_url}/evaluate-reverse-polish-notation/[150. 逆波兰表达式求值^]
|{doc_base_url}/0150-evaluate-reverse-polish-notation.adoc[题解]
|✅ 遇到数字就入栈，遇到运算符号就将栈顶元素出栈，计算完成后再入栈。

|{counter:codes2503}
|{leetcode_base_url}/reverse-words-in-a-string/[151. 反转字符串中的单词^]
|{doc_base_url}/0151-reverse-words-in-a-string.adoc[题解]
|✅ 双指针，切割对调。

|{counter:codes2503}
|{leetcode_base_url}/find-minimum-in-rotated-sorted-array/[153. 寻找旋转排序数组中的最小值^]
|{doc_base_url}/0153-find-minimum-in-rotated-sorted-array.adoc[题解]
|✅ 二分查找！只要聚焦于最低点所在局域即可。其他区域可以忽略。

|{counter:codes2503}
|{leetcode_base_url}/binary-search-tree-iterator/[173. 二叉搜索树迭代器^]
|{doc_base_url}/0173-binary-search-tree-iterator.adoc[题解]
|✅ 栈。使用栈模拟递归调用。

|{counter:codes2503}
|{leetcode_base_url}/bitwise-and-of-numbers-range/[201. 数字范围按位与^]
|{doc_base_url}/0201-bitwise-and-of-numbers-range.adoc[题解]
|⭕️ 位运算！暴力解法超时！可以利用 stem:[n&(n-1)] 去掉 `n` 的最后一位 `1`，反复计算，直到范围的左边界为止即可得到答案。

|{counter:codes2503}
|{leetcode_base_url}/word-search-ii/[212. 单词搜索 II^]
|{doc_base_url}/0212-word-search-ii.adoc[题解]
|⭕️ 回溯，通过 43 / 65 个测试用例，后超时。利用前缀树+回溯，可以避免重复判断单词相同的前缀部分，可以节省大量的计算。

|{counter:codes2503}
|{leetcode_base_url}/contains-duplicate-ii/[219. 存在重复元素 II^]
|{doc_base_url}/0219-contains-duplicate-ii.adoc[题解]
|✅ 使用哈希存每个数字的最后坐标，遇到相同就判断是否满足条件，否则继续推进。看题解，只保存滑动窗口范围内的数字，可以更节省内存！

|{counter:codes2503}
|{leetcode_base_url}/summary-ranges/[228. 汇总区间^]
|{doc_base_url}/0228-summary-ranges.adoc[题解]
|✅ 双指针：一个指针记录起始位置，一个指针向前推进，有起始则区间加入，没有则单独加入。

|{counter:codes2503}
|{leetcode_base_url}/h-index/[274. H 指数^]
|{doc_base_url}/0274-h-index.adoc[题解]
|✅ 排序，从后向前，假如当前数字大于 `h` 指数，则向前移动，同时 `h++`，直到不符合条件。没想到，竟然一次过！

|{counter:codes2503}
|{leetcode_base_url}/word-pattern/[290. 单词规律^]
|{doc_base_url}/0290-word-pattern.adoc[题解]
|✅ 哈希，从字符串截取单词，跟 `pattern` 中的字符建立起一对一的对应关系，发现关系被打破，就返回 `false`。直到最后，返回 `true`。

|{counter:codes2503}
|{leetcode_base_url}/find-k-pairs-with-smallest-sums/[373. 查找和最小的 K 对数字^]
|{doc_base_url}/0373-find-k-pairs-with-smallest-sums.adoc[题解]
|✅ 使用优先队列，存放最小的 `k` 个组合，使用最大堆，遇到更小的和，就弹出堆顶，加入新组合。

|{counter:codes2503}
|{leetcode_base_url}/ransom-note/[383. 赎金信^]
|{doc_base_url}/0383-ransom-note.adoc[题解]
|✅ 先统计 `magazine` 每个字符数量，然后遍历 `ransomNote` 中的字符，在统计数量上做减法，出现负数则不满足要求。

|{counter:codes2503}
|{leetcode_base_url}/evaluate-division/[399. 除法求值^]
|{doc_base_url}/0399-evaluate-division.adoc[题解]
|❌ 将代数式翻译成代码，完全没有思路！一脸懵逼！直接抄的官方题解！

|{counter:codes2503}
|{leetcode_base_url}/construct-quad-tree/[427. 建立四叉树^]
|{doc_base_url}/0427-construct-quad-tree.adoc[题解]
|✅ 递归+分治。注意：一个区域内是否相等不能靠底层的节点来判断，需要遍历所有的节点值。

|{counter:codes2503}
|{leetcode_base_url}/minimum-genetic-mutation/[433. 最小基因变化^]
|{doc_base_url}/0433-minimum-genetic-mutation.adoc[题解]
|⭕️ 广度优先遍历。原来会的类型，好久不做，都快忘完了！

|{counter:codes2503}
|{leetcode_base_url}/minimum-number-of-arrows-to-burst-balloons/[452. 用最少数量的箭引爆气球^]
|{doc_base_url}/0452-minimum-number-of-arrows-to-burst-balloons.adoc[题解]
|✅ 对坐标区间排序，然后进行区间合并，最后统计只剩几个区间即可。看题解，也不需要保存区间，只需要记录最后一个区间的右端就可以统计出区间数量。也有一个类似的贪心思路解法。

|{counter:codes2503}
|{leetcode_base_url}/ipo/[502. IPO^]
|{doc_base_url}/0502-ipo.adoc[题解]
|⭕️ 贪心+大顶堆。每次都在可选的范围内，盈利最大的！通过 35 / 40 个测试用例，超时！有思路，可惜没想好怎么写代码！

|{counter:codes2503}
|{leetcode_base_url}/snakes-and-ladders/[909. 蛇梯棋^]
|{doc_base_url}/0909-snakes-and-ladders.adoc[题解]
|✅ 广度优先遍历。先构建坐标到数字和数字到坐标的对应关系，然后通过入队出队尝试每一步，直到终点或者不可达。使用移位将坐标转换成一个数字，在一个 `Map` 对象中存正向和反向的对应关系。看题解，可以把矩阵转换成一维数组，处理更简单，真是妙啊！

|{counter:codes2503}
|{leetcode_base_url}/valid-sudoku/[36. 有效的数独^]
|{doc_base_url}/0036-valid-sudoku.adoc[题解]
|✅ 对行、列和块三部分分别判断是否含有重复数字即可。不是求解，只是合法性判断！

|{counter:codes2503}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|✅ 回溯！做 {doc_base_url}/0036-valid-sudoku.adoc[36. 有效的数独] 时，当做“解数独”来做了。一做两题了！

|{counter:codes2503}
|{leetcode_base_url}/n-queens-ii/[52. N 皇后 II^]
|{doc_base_url}/0052-n-queens-ii.adoc[题解]
|✅ 回溯！有机会尝试一下位运算！看题解，不需要构建矩阵也可以模拟棋盘。

|{counter:codes2503}
|{leetcode_base_url}/text-justification/[68. 文本左右对齐^]
|{doc_base_url}/0068-text-justification.adoc[题解]
|❌ 有思路，但是没有对思路进行分类。参考题解，分为“最后一行”、“一个单词一行”和“多个单词一行”来分别处理。

|{counter:codes2503}
|{leetcode_base_url}/interleaving-string/[97. 交错字符串^]
|{doc_base_url}/0097-interleaving-string.adoc[题解]
|❌ 动态规划。思考 `s3` 最后一个字符时从 `s1` 来，还是从 `s2` 来，上一个位置又是哪里？

|{counter:codes2503}
|{leetcode_base_url}/wildcard-matching/[44. 通配符匹配^]
|{doc_base_url}/0044-wildcard-matching.adoc[题解]
|❌ 动态规划。尝试双指针失败！完全没有想到可以用动态规划来解决这个问题！

|{counter:codes2503}
|{leetcode_base_url}/maximal-rectangle/[85. 最大矩形^]
|{doc_base_url}/0085-maximal-rectangle.adoc[题解]
|❌ 单调栈！计算每一行的高度，然后利用这个高度，使用与 {leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^] 中相同的思路，结合单调栈的模式来解决问题。多种解法，还有动态规划的解法。

|{counter:codes2503}
|{leetcode_base_url}/insertion-sort-list/[147. 对链表进行插入排序^]
|{doc_base_url}/0147-insertion-sort-list.adoc[题解]
|✅ 链表操作。📢：只有当前节点比前驱节点大时，才向后 移动指针。否则，无需移动指针。

|{counter:codes2503}
|{leetcode_base_url}/compare-version-numbers/[165. 比较版本号^]
|{doc_base_url}/0165-compare-version-numbers.adoc[题解]
|✅ 双指针。一个指针指向一个字符串下标，从指针位置取一个修订号的值，然后比较，再取下一个修订号。

|{counter:codes2503}
|{leetcode_base_url}/excel-sheet-column-title/[168. Excel表列名称^]
|{doc_base_url}/0168-excel-sheet-column-title.adoc[题解]
|✅ 进制转换！虽然最终做出来了，但掌握的还是不够透彻！

|{counter:codes2503}
|{leetcode_base_url}/dungeon-game/[174. 地下城游戏^]
|{doc_base_url}/0174-dungeon-game.adoc[题解]
|✅ 动态规划！从终点向起始位置反推。遇到正数就直接加，遇到负数则先看看上一步的最大值是正数还是负数，是负数则需要累加，是正数则舍弃，直接从当前位置的负数算起。

|{counter:codes2503}
|{leetcode_base_url}/maximum-gap/[164. 最大间距^]
|{doc_base_url}/0164-maximum-gap.adoc[题解]
|✅ 使用比特位表示每个数字！这样统计每个比特位之间的差值即可。更优解是基数排序，抽空学习一下。

|{counter:codes2503}
|{leetcode_base_url}/repeated-dna-sequences/[187. 重复的DNA序列^]
|{doc_base_url}/0187-repeated-dna-sequences.adoc[题解]
|✅ 暴力法，通过 30/31 个测试用例。使用子串+哈希优化一下即可。看题解，还有滑动窗口，有机会学习一下。

|{counter:codes2503}
|{leetcode_base_url}/word-frequency/[192. 统计词频^]
|{doc_base_url}/0192-word-frequency.adoc[题解]
|✅ 以为是算法题，没想到是 Bash 脚本编程题！

|{counter:codes2503}
|{leetcode_base_url}/shortest-palindrome/[214. 最短回文串^]
|{doc_base_url}/0214-shortest-palindrome.adoc[题解]
|✅ 反转字符串，选择反转字符串结尾和原始字符串开头相同部分，再截取前缀+原始字符串即可获得答案！通过 124 / 126 个测试用例。使用 `reversed.substring(index)` 代替逐个字母比较，答案通过！更牛逼的写法是 KMP 算法。

|{counter:codes2503}
|{leetcode_base_url}/longest-harmonious-subsequence/[594. 最长和谐子序列^]
|{doc_base_url}/0594-longest-harmonious-subsequence.adoc[题解]
|✅ 最简单的解法是排序。时间复杂度更优的解答是哈希计数。

|{counter:codes2503}
|{leetcode_base_url}/rectangle-area/[223. 矩形面积^]
|{doc_base_url}/0223-rectangle-area.adoc[题解]
|⭕️ 原本还想按分离，包含和相交三种情况来处理，相交情况太多，放弃！容斥原理的处理手段和 {doc_base_url}/0000-04-merge-intervals.adoc[Merge Intervals 区间合并] 题目的方式类似！

|{counter:codes2503}
|{leetcode_base_url}/implement-stack-using-queues/[225. 用队列实现栈^]
|{doc_base_url}/0225-implement-stack-using-queues.adoc[题解]
|✅ 就是用两个队列来回倒腾。添加元素的时候，哪个空就放那个队列中，把另外一个队列里的值都倒腾过来。

|{counter:codes2503}
|{leetcode_base_url}/majority-element-ii/[229. 多数元素 II^]
|{doc_base_url}/0229-majority-element-ii.adoc[题解]
|⭕️ 最简单解法是哈希计数法。更精美的解法是摩尔投票法，通过抵消不同元素的出现次数，最后剩余下的元素可能就是符合要求元素。

|{counter:codes2503}
|{leetcode_base_url}/different-ways-to-add-parentheses/[241. 为运算表达式设计优先级^]
|{doc_base_url}/0241-different-ways-to-add-parentheses.adoc[题解]
|❌ 看完题目首先想的是怎么插入括号。看了题解，可以按运算符将左右分为两部分进行递归求解，再分别对左右进行计算。

|{counter:codes2503}
|{leetcode_base_url}/add-digits/[258. 各位相加^]
|{doc_base_url}/0258-add-digits.adoc[题解]
|✅ 数学计算。

|{counter:codes2503}
|{leetcode_base_url}/ugly-number/[263. 丑数^]
|{doc_base_url}/0263-ugly-number.adoc[题解]
|✅ 数学计算。

|{counter:codes2503}
|{leetcode_base_url}/ugly-number-ii/[264. 丑数 II^]
|{doc_base_url}/0264-ugly-number-ii.adoc[题解]
|✅ 优先队列

|{counter:codes2503}
|{leetcode_base_url}/h-index-ii/[275. H 指数 II^]
|{doc_base_url}/0275-h-index-ii.adoc[题解]
|✅ 二分查找

|{counter:codes2503}
|{leetcode_base_url}/expression-add-operators/[282. 给表达式添加运算符^]
|{doc_base_url}/0282-expression-add-operators.adoc[题解]
|⭕️ 回溯！对切分的数字和运算符进行遍历。想到了思路，实现出了问题。

|{counter:codes2503}
|{leetcode_base_url}/peeking-iterator/[284. 窥视迭代器^]
|{doc_base_url}/0284-peeking-iterator.adoc[题解]
|✅ 调用 `peek()` 时，调用 `next()` 把头部元素存入到属性字段 `header` 中。

|{counter:codes2503}
|{leetcode_base_url}/nim-game/[292. Nim 游戏^]
|{doc_base_url}/0292-nim-game.adoc[题解]
|✅ 数学推理。


|{counter:codes2503}
|{leetcode_base_url}/additive-number/[306. 累加数^]
|{doc_base_url}/0306-additive-number.adoc[题解]
|✅ 深度优先搜索。逐步截取字符串，累加，向后推进。题解都叫回溯，D瓜哥这里没有回溯的操作，只使用了深度优先搜索。

|{counter:codes2503}
|{leetcode_base_url}/minimum-height-trees/[310. 最小高度树^]
|{doc_base_url}/0310-minimum-height-trees.adoc[题解]
|⭕️ 优化前：深度优先遍历，通过 68 / 71 测试用例，超时。看题解，使用从外向内靠拢的广度优先遍历解法解决了这个问题。网友称之为剪窗花思路。

|{counter:codes2503}
|{leetcode_base_url}/super-ugly-number/[313. Super Ugly Number^]
|{doc_base_url}/0313-super-ugly-number.adoc[题解]
|✅ 优先队列。从优先队列中取出最小的数与给定的质数数组元素相乘，生成后续的丑数。

|{counter:codes2503}
|{leetcode_base_url}/maximum-product-of-word-lengths/[318. 最大单词长度乘积^]
|{doc_base_url}/0318-maximum-product-of-word-lengths.adoc[题解]
|✅ 计算每一个单词的字母占用情况，然后逐个比较，没有相同字母，则计算单词长度乘积，最后取最大值返回即可。

|{counter:codes2503}
|{leetcode_base_url}/bulb-switcher/[319. 灯泡开关^]
|{doc_base_url}/0319-bulb-switcher.adoc[题解]
|⭕️ 优化前：模拟开灯过程，通过 33 / 35 测试用例，超时。看题解，没想到竟然是找 `[1, n]` 之间的平方数。

|{counter:codes2503}
|{leetcode_base_url}/power-of-four/[342. 4的幂^]
|{doc_base_url}/0342-power-of-four.adoc[题解]
|✅ 数学题，也可以说是比特位题。

|{counter:codes2503}
|{leetcode_base_url}/reverse-vowels-of-a-string/[345. 反转字符串中的元音字母^]
|{doc_base_url}/0345-reverse-vowels-of-a-string.adoc[题解]
|✅ 双指针！从字符串两端寻找元音字符，然后进行交换。注意大小写！

|{counter:codes2503}
|{leetcode_base_url}/intersection-of-two-arrays/[349. 两个数组的交集^]
|{doc_base_url}/0349-intersection-of-two-arrays.adoc[题解]
|✅ 排序+双指针！也可以使用 `Set`，只是空间复杂度高一点。

|{counter:codes2503}
|{leetcode_base_url}/design-twitter/[355. 设计推特^]
|{doc_base_url}/0355-design-twitter.adoc[题解]
|✅ 利用列表存储，来维持前后顺序；或者，增加时间戳字段。

|{counter:codes2503}
|{leetcode_base_url}/count-numbers-with-unique-digits/[357. 统计各位数字都不同的数字个数^]
|{doc_base_url}/0357-count-numbers-with-unique-digits.adoc[题解]
|✅ 数学题。排列组合。

|{counter:codes2503}
|{leetcode_base_url}/water-and-jug-problem/[365. 水壶问题^]
|{doc_base_url}/0365-water-and-jug-problem.adoc[题解]
|❌ 深度优先遍历、广度优先遍历或数学（link:++https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593[裴蜀定理^]++[贝祖定理]）。这道题重点是如何抽象倒水壶的表示办法以及梳理清楚存在几种可能的操作。

|{counter:codes2503}
|{leetcode_base_url}/valid-perfect-square/[367. 有效的完全平方数^]
|{doc_base_url}/0367-valid-perfect-square.adoc[题解]
|✅ 二分查找。需要注意处理平方溢出的情况。

|{counter:codes2503}
|{leetcode_base_url}/largest-divisible-subset/[368. 最大整除子集^]
|{doc_base_url}/0368-largest-divisible-subset.adoc[题解]
|❌ 动态规划！将这个问题转换成最长子序列的思路，以及代码写法非常值得学习！

|{counter:codes2503}
|{leetcode_base_url}/super-pow/[372. 超级次方^]
|{doc_base_url}/0372-super-pow.adoc[题解]
|⭕️ 数学计算+分治算法。重点是要搞清楚，两个数字相乘求模，等于分别对两个数求模，相乘然后再求模。基本思路搞明白了，数学计算处理错了。

|{counter:codes2503}
|{leetcode_base_url}/guess-number-higher-or-lower/[374. 猜数字大小^]
|{doc_base_url}/0374-guess-number-higher-or-lower.adoc[题解]
|✅ 二分查找。

|{counter:codes2503}
|{leetcode_base_url}/wiggle-subsequence/[376. 摆动序列^]
|{doc_base_url}/0376-wiggle-subsequence.adoc[题解]
|❌ 贪心算法。一脸懵逼，看答案才懂。

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-iv/[377. 组合总和 Ⅳ^]
|{doc_base_url}/0377-combination-sum-iv.adoc[题解]
|❌ 动态规划 - 完全背包问题。起初以为是回溯，没想到是完全背包问题。

|{counter:codes2503}
|{leetcode_base_url}/linked-list-random-node/[382. 链表随机节点^]
|{doc_base_url}/0382-linked-list-random-node.adoc[题解]
|✅ 转数组或随机选数从头找选中的节点。感觉蓄水池抽样算法不让直接随机选择数字向后遍历效率高。

|{counter:codes2503}
|{leetcode_base_url}/find-the-difference/[389. 找不同^]
|{doc_base_url}/0389-find-the-difference.adoc[题解]
|✅ 哈希或异或。

|{counter:codes2503}
|{leetcode_base_url}/utf-8-validation/[393. UTF-8 编码验证^]
|{doc_base_url}/0393-utf-8-validation.adoc[题解]
|✅ 位运算

|{counter:codes2503}
|{leetcode_base_url}/rotate-function/[396. 旋转函数^]
|{doc_base_url}/0396-rotate-function.adoc[题解]
|⭕️ 暴力破解，模拟整个计算过程来求结果，通过 45 / 58 个测试用例，超时。

|{counter:codes2503}
|{leetcode_base_url}/integer-replacement/[397. 整数替换^]
|{doc_base_url}/0397-integer-replacement.adoc[题解]
|✅ 深度优先搜索！计算每一个转换，在每一步中取最小值，即可得到结果。

|{counter:codes2503}
|{leetcode_base_url}/random-pick-index/[398. 随机数索引^]
|{doc_base_url}/0398-random-pick-index.adoc[题解]
|✅ 哈希或蓄水池抽样算法。

|{counter:codes2503}
|{leetcode_base_url}/binary-watch/[401. 二进制手表^]
|{doc_base_url}/0401-binary-watch.adoc[题解]
|✅ 回溯或位操作。小时数和分钟数都有上限，这点需注意！

|{counter:codes2503}
|{leetcode_base_url}/convert-a-number-to-hexadecimal/[405. 数字转换为十六进制数^]
|{doc_base_url}/0405-convert-a-number-to-hexadecimal.adoc[题解]
|✅ 位运算。可以直接转换成十六进制，不需要从二进制绕一下。

|{counter:codes2503}
|{leetcode_base_url}/arithmetic-slices/[413. Arithmetic Slices^]
|{doc_base_url}/0413-arithmetic-slices.adoc[题解]
|✅ 选择一个元素做起点，向前探索可以成为等差数组的可能。竟然可以用滑动窗口！

|{counter:codes2503}
|{leetcode_base_url}/third-maximum-number/[414. Third Maximum Number^]
|{doc_base_url}/0414-third-maximum-number.adoc[题解]
|✅ 竟然可以使用三个变量来保存第一、二、三大数。这样，遍历一遍即可得到这三个数字。

|{counter:codes2503}
|{leetcode_base_url}/pacific-atlantic-water-flow/[417. 太平洋大西洋水流问题^]
|{doc_base_url}/0417-pacific-atlantic-water-flow.adoc[题解]
|⭕️ 题目有点不明觉厉！搞清楚题目要求，就是一个 DFS 或 BFS：分别以靠着海洋的点为起点，找出“步步高升”的点，最后求两个海洋的高点交集。

|{counter:codes2503}
|{leetcode_base_url}/battleships-in-a-board/[419. 棋盘上的战舰^]
|{doc_base_url}/0419-battleships-in-a-board.adoc[题解]
|✅ 修改矩阵的解法很简单！不修改矩阵且时间复杂度是 stem:[O(1)]，写代码就有点技巧：遇到第一个战舰计数，当上一个节点或者做一个节点也是战舰时，就跳过！

|{counter:codes2503}
|{leetcode_base_url}/reconstruct-original-digits-from-english/[423. 从英文中重建数字^]
|{doc_base_url}/0423-reconstruct-original-digits-from-english.adoc[题解]
|⭕️ 按照最初想法，先统计每个字符出现的次数，然后再按照数字顺序，逐个去尝试是否在字符串中。这样时间复杂度就不可控。看题解，可以按照单词中的字符出现特性，先将只出现在一个数字中的字符挑选出来，确定对应的数字出现次数。然后，在处理出现中两个数字中的字符，逐步把所有数字出现次数确定好。

|{counter:codes2503}
|{leetcode_base_url}/number-of-segments-in-a-string/[434. 字符串中的单词数^]
|{doc_base_url}/0434-number-of-segments-in-a-string.adoc[题解]
|✅ 识别单词开头，进行数量统计。

|{counter:codes2503}
|{leetcode_base_url}/queue-reconstruction-by-height/[406. 根据身高重建队列^]
|{doc_base_url}/0406-queue-reconstruction-by-height.adoc[题解]
|⭕️ 一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。

|{counter:codes2503}
|{leetcode_base_url}/maximum-xor-of-two-numbers-in-an-array/[421. 数组中两个数的最大异或值^]
|{doc_base_url}/0421-maximum-xor-of-two-numbers-in-an-array.adoc[题解]
|❌ 前缀树或哈希！这道题可以换个思路来理解：选出两个数，小数正好可以“补齐”大数尽可能高位的 `0` 所在的比特位。这也能叫中等难度题目？

|{counter:codes2503}
|{leetcode_base_url}/longest-repeating-character-replacement/[424. Longest Repeating Character Replacement^]
|{doc_base_url}/0424-longest-repeating-character-replacement.adoc[题解]
|❌ 滑动窗口。难点在于，如何判断一个字符串改变 K 个字符，能够变成一个连续串？

|{counter:codes2503}
|{leetcode_base_url}/flatten-a-multilevel-doubly-linked-list/[430. Flatten a Multilevel Doubly Linked List^]
|{doc_base_url}/0430-flatten-a-multilevel-doubly-linked-list.adoc[题解]
|⭕️ 深度优先遍历。思路有，但是代码写不出来！还是得多练！逐个元素处理，遇到有子元素的情况，则“向下”一层，将下一层做扁平化处理。

|{counter:codes2503}
|{leetcode_base_url}/arranging-coins/[441. Arranging Coins^]
|{doc_base_url}/0441-arranging-coins.adoc[题解]
|✅ 二分查找或数学。一元二次方程求根公式。

|{counter:codes2503}
|{leetcode_base_url}/non-overlapping-intervals/[435. Non-overlapping Intervals^]
|{doc_base_url}/0435-non-overlapping-intervals.adoc[题解]
|❌ 贪心算法。换个角度，改为计算最多可以选多少个互不重叠的区间。

|{counter:codes2503}
|{leetcode_base_url}/find-right-interval/[436. 寻找右区间^]
|{doc_base_url}/0436-find-right-interval.adoc[题解]
|❌ 排序+二分查找。由于左端点都不同，可以根据左端点的值来来对区间进行排序。然后在这个有序序列中，查找右端点的“最近左端点”。

|{counter:codes2503}
|{leetcode_base_url}/find-all-duplicates-in-an-array/[442. 数组中重复的数据^]
|{doc_base_url}/0442-find-all-duplicates-in-an-array.adoc[题解]
|⭕️ {doc_base_url}/0000-12-cyclic-sort.adoc[Cyclic Sort 循环排序]。想到了排序的思路，但是把“循环排序”的模式给忘记了，更没有把具体步骤没有理清楚。

|{counter:codes2503}
|{leetcode_base_url}/string-compression/[443. 压缩字符串^]
|{doc_base_url}/0443-string-compression.adoc[题解]
|✅ 双指针。一个指针 `fast` 指向当前处理的下标，一个指针 `curr` 指向当前循环的起始位置，最后一个指针 `slow` 指向可以存放压缩字符的位置。不断向前循环统计数量，向后压缩。

|{counter:codes2503}
|{leetcode_base_url}/add-two-numbers-ii/[445. 两数相加 II^]
|{doc_base_url}/0445-add-two-numbers-ii.adoc[题解]
|✅ 将链表以短链表的长度为准分割成收尾两部分，尾部相加，再“嫁接”到截取下来的首部。

|{counter:codes2503}
|{leetcode_base_url}/number-of-boomerangs/[447. 回旋镖的数量^]
|{doc_base_url}/0447-number-of-boomerangs.adoc[题解]
|⭕️ 暴力破解。通过 25/32 个测试用例。利用排列组合原理也优化，统计相同距离的点数，组成的回旋镖需要两个点，则数量为：stem:[A_{n}^{2}=\frac{n!}{(n-2)!} = n(n-1)]。

|{counter:codes2503}
|{leetcode_base_url}/sort-characters-by-frequency/[451. 根据字符出现频率排序^]
|{doc_base_url}/0451-sort-characters-by-frequency.adoc[题解]
|✅ 先统计再排序。注意：如果两个字符的数量相等时，还需要根据自身的自然顺序排序，否则就会被 `SequencedMap` 吞掉一个。

|{counter:codes2503}
|{leetcode_base_url}/assign-cookies/[455. 分发饼干^]
|{doc_base_url}/0455-assign-cookies.adoc[题解]
|✅ 排序+双指+可选的贪心。

|{counter:codes2503}
|{leetcode_base_url}/circular-array-loop/[457. 环形数组是否存在循环^]
|{doc_base_url}/0457-circular-array-loop.adoc[题解]
|✅ 使用回溯，对每一个元素做深度优先遍历。遇到环形数组则返回，否则继续向前遍历，直到结束。优化：遍历过的节点肯定不是环形数组，遇到遍历过的节点，直接“返回 false”，这样，所有节点只需要出来一次，时间复杂度 stem:[O(n)]。

|{counter:codes2503}
|{leetcode_base_url}/132-pattern/[456. 132 模式^]
|{doc_base_url}/0456-132-pattern.adoc[题解]
|❌ 单调栈！完全没想到单调栈的解法！从右向左遍历，使用一个单调递减栈，来维护 `32` 的关系：弹出的就是 `2`，栈中的就是 `3`，当前元素小于 `k` 时，就找到了 `132` 模式。

|{counter:codes2503}
|{leetcode_base_url}/repeated-substring-pattern/[459. 重复的子字符串^]
|{doc_base_url}/0459-repeated-substring-pattern.adoc[题解]
|✅ 对字符串进行以 `length/i` 为长度的分割，分配来判断是否可以由子串重复得来。

|{counter:codes2503}
|{leetcode_base_url}/lfu-cache/[460. LFU Cache^]
|{doc_base_url}/0460-lfu-cache.adoc[题解]
|❌ 太难了！

|{counter:codes2503}
|{leetcode_base_url}/hamming-distance/[461. 汉明距离^]
|{doc_base_url}/0461-hamming-distance.adoc[题解]
|✅ 数学。求一个数的二进制中 `1` 的个数，最快的算法是 Brian Kernighan 算法，latexmath:[f(x) = x \& (x−1)]，可以跳过两个 `1` 之间的 `0`。

|{counter:codes2503}
|{leetcode_base_url}/island-perimeter/[463. 岛屿的周长^]
|{doc_base_url}/0463-island-perimeter.adoc[题解]
|✅ 深度优先或者广度优先。

|{counter:codes2503}
|{leetcode_base_url}/validate-ip-address/[468. 验证IP地址^]
|{doc_base_url}/0468-validate-ip-address.adoc[题解]
|✅ 字符串操作，规则判断，没意思。

|{counter:codes2503}
|{leetcode_base_url}/implement-rand10-using-rand7/[470. 用 Rand7() 实现 Rand10()^]
|{doc_base_url}/0470-implement-rand10-using-rand7.adoc[题解]
|✅ 数学。拒绝采样。蒙对了。调用 10 次，生成 `[10, 70]` 的随机数，在除 `10` 求余数即可。更高效的做法是充分利用拒绝采样的数据，再次生成随机数。

|{counter:codes2503}
|{leetcode_base_url}/matchsticks-to-square/[473. 火柴拼正方形^]
|{doc_base_url}/0473-matchsticks-to-square.adoc[题解]
|❌ 回溯。有思路，没代码。“从边到火柴”，还是“从火柴到边”？

|{counter:codes2503}
|{leetcode_base_url}/heaters/[475. 供暖器^]
|{doc_base_url}/0475-heaters.adoc[题解]
|❌ 二分查找。对加热器排序，对每一个房子寻找左侧最近的加热器，然后计算两侧加热器哪个最近？对于所有房子来说，做大的最近距离就能满足所有房子的加热需求。

|{counter:codes2503}
|{leetcode_base_url}/number-complement/[476. 数字的补数^]
|{doc_base_url}/0476-number-complement.adoc[题解]
|✅ 数学。位运算。

|{counter:codes2503}
|{leetcode_base_url}/total-hamming-distance/[477. 汉明距离总和^]
|{doc_base_url}/0477-total-hamming-distance.adoc[题解]
|✅ 数学。位运算。通过求所有数字在一个指定比特位上的 `1`（`c`） 和 `0`（`n - c`） 数量，再相乘 stem:[c*(n-c)]，就这个比特位上的汉明距离，最后把每一位的汉明距离相加，得到汉明距离的总和。

|{counter:codes2503}
|{leetcode_base_url}/generate-random-point-in-a-circle/[478. 在圆内随机生成点^]
|{doc_base_url}/0478-generate-random-point-in-a-circle.adoc[题解]
|✅ 数学。拒绝采样。利用图像平移，在 `(r, r)` 圆生成符合要求的随机数，然后再平移到原始圆附近。

|{counter:codes2503}
|{leetcode_base_url}/magical-string/[481. 神奇字符串^]
|{doc_base_url}/0481-magical-string.adoc[题解]
|❌ 双指针。但感觉有数学的感觉。有大概思路，忽略了 `12` 交替出现的隐含条件。

|{counter:codes2503}
|{leetcode_base_url}/license-key-formatting/[482. 密钥格式化^]
|{doc_base_url}/0482-license-key-formatting.adoc[题解]
|✅ 字符串。从后向前，遍历字符串。

|{counter:codes2503}
|{leetcode_base_url}/range-addition/[370. 区间加法^]
|{doc_base_url}/0370-range-addition.adoc[题解]
|✅ Plus专题。复习 {doc_base_url}/0000-02-difference-array.adoc[Difference Array 差分数组]

|{counter:codes2503}
|{leetcode_base_url}/car-pooling/[1094. 拼车^]
|{doc_base_url}/1094-car-pooling.adoc[题解]
|✅ 复习 {doc_base_url}/0000-02-difference-array.adoc[Difference Array 差分数组]

|{counter:codes2503}
|{leetcode_base_url}/range-sum-query-immutable/[303. 区域和检索 - 数组不可变^]
|{doc_base_url}/0303-range-sum-query-immutable.adoc[题解]
|✅ 复习 {doc_base_url}/0000-03-prefix-sum.adoc[Prefix Sum 前缀和]

|{counter:codes2503}
|{leetcode_base_url}/find-first-and-last-position-of-element-in-sorted-array/[34. 在排序数组中查找元素的第一个和最后一个位置^]
|{doc_base_url}/0034-find-first-and-last-position-of-element-in-sorted-array.adoc[题解]
|✅ {doc_base_url}/0000-01-modified-binary-search.adoc[二分查找]。寻找边界时，找左收右，找右收左。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|❌ {doc_base_url}/0000-01-modified-binary-search.adoc[二分查找]。先在有序部分内查找，找不到则去另外一部分去查找。重点是识别出哪部分是有序部分。还想到一个思路：先找拐点，再分段去查找，代码各种问题。没有完全写对。

|{counter:codes2503}
|{leetcode_base_url}/happy-number/[202. 快乐数^]
|{doc_base_url}/0202-happy-number.adoc[题解]
|✅ 复习 {doc_base_url}/0000-07-fast-slow-pointers.adoc[Fast & Slow Pointers 快慢指针]

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-list-ii/[82. 删除排序链表中的重复元素 II^]
|{doc_base_url}/0082-remove-duplicates-from-sorted-list-ii.adoc[题解]
|✅ 复习 {doc_base_url}/0000-07-fast-slow-pointers.adoc[Fast & Slow Pointers 快慢指针]。不比拘泥于快慢指针；也不比拘泥于一层循环，嵌套的内层循环向前推进，也会带动外层循环向前推进。

|{counter:codes2503}
|{leetcode_base_url}/merge-intervals/[56. 合并区间^]
|{doc_base_url}/0056-merge-intervals.adoc[题解]
|✅ 复习 {doc_base_url}/0000-04-merge-intervals.adoc[Merge Intervals 区间合并]。对区间进行排序，然后快慢指针在当前数组上对其进行合并。

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 复习 {doc_base_url}/0000-06-two-pointer.adoc[Two Pointer 双指针]。双指针+递归降维。

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-without-repeating-characters/[3. 无重复字符的最长子串^]
|{doc_base_url}/0003-longest-substring-without-repeating-characters.adoc[题解]
|✅ 复习 {doc_base_url}/0000-09-sliding-window.adoc[Sliding Window 滑动窗口]。我采用的是计数法，也可以采用地址法。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicate-letters/[316. 去除重复字母^]
|{doc_base_url}/0316-remove-duplicate-letters.adoc[题解]
|❌ 复习 {doc_base_url}/0000-10-monotonic-stack.adoc[Monotonic Stack 单调栈]。知道是单调栈，代码还是没写出来！看到题解，又里面秒懂。

|{counter:codes2503}
|{leetcode_base_url}/remove-k-digits/[402. 移掉 K 位数字^]
|{doc_base_url}/0402-remove-k-digits.adoc[题解]
|⭕️ 单调栈。利用单调递增栈，将“当前元素”前面更大的元素都删除掉，这样就可以实现尽可能大的减小这个数字。如果数字是递增的，那么就从后面向前删除，直到删够为止。

|{counter:codes2503}
|{leetcode_base_url}/top-k-frequent-elements/[347. 前 K 个高频元素^]
|{doc_base_url}/0347-top-k-frequent-elements.adoc[题解]
|✅ Top K 问题，优先队列；桶排序；也可以利用快速选择。

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|⭕️ 快速选择。有思路，但代码总报错！还需要多练！

|{counter:codes2503}
|{leetcode_base_url}/first-missing-positive/[41. 缺失的第一个正数^]
|{doc_base_url}/0041-first-missing-positive.adoc[题解]
|✅ 循环排序。

|{counter:codes2503}
|{leetcode_base_url}/find-median-from-data-stream/[295. 数据流的中位数^]
|{doc_base_url}/0295-find-median-from-data-stream.adoc[题解]
|✅ 对顶堆。每次添加，都要在两个堆之间倒腾一下，这样才能保证，小的沉下去，大的升上去。

|{counter:codes2503}
|{leetcode_base_url}/sliding-window-median/[480. 滑动窗口中位数^]
|{doc_base_url}/0480-sliding-window-median.adoc[题解]
|⭕️ 滑动窗口+对顶堆。单纯利用对顶堆，只能通过 43 / 44 个测试用例。延迟删除的实现有些复杂，还要再研究一下。

|{counter:codes2503}
|{leetcode_base_url}/design-twitter/[355. 设计推特^]
|{doc_base_url}/0355-design-twitter.adoc[题解]
|✅ 多路归并的解法。

|{counter:codes2503}
|{leetcode_base_url}/symmetric-tree/[101. 对称二叉树^]
|{doc_base_url}/0101-symmetric-tree.adoc[题解]
|✅ 广度优先搜索或深度优先搜索。这次尝试使用广度优先搜索+遍历来解决问题。

|{counter:codes2503}
|{leetcode_base_url}/count-unreachable-pairs-of-nodes-in-an-undirected-graph/[2316. 统计无向图中无法互相到达点对数^]
|{doc_base_url}/2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph.adoc[题解]
|⭕️ 深度优先遍历 + 乘法原理。有思路，代码没写利索。这道题还可以使用并查集来解决。

|{counter:codes2503}
|{leetcode_base_url}/replace-words/[648. 单词替换^]
|{doc_base_url}/0648-replace-words.adoc[题解]
|✅ 前缀树。

|{counter:codes2503}
|{leetcode_base_url}/satisfiability-of-equality-equations/[990. Satisfiability of Equality Equations^]
|{doc_base_url}/0990-satisfiability-of-equality-equations.adoc[题解]
|✅ 并查集，将式子分为两类，添加等式，查询不等式，相连就报错。

|{counter:codes2503}
|{leetcode_base_url}/minimum-number-of-vertices-to-reach-all-nodes/[1557. 可以到达所有点的最少点数目^]
|{doc_base_url}/1557-minimum-number-of-vertices-to-reach-all-nodes.adoc[题解]
|✅ 拓扑排序。基础款，只需要找出入度为 `0` 的节点即可。

|{counter:codes2503}
|{leetcode_base_url}/find-all-possible-recipes-from-given-supplies/[2115. 从给定原材料中找到所有可以做出的菜^]
|{doc_base_url}/2115-find-all-possible-recipes-from-given-supplies.adoc[题解]
|✅ 拓扑排序。在拓扑排序的基础上，对起点和涉及到的点做了限制。

|{counter:codes2503}
|{leetcode_base_url}/accounts-merge/[721. 账户合并^]
|{doc_base_url}/0721-accounts-merge.adoc[题解]
|✅ {doc_base_url}/0000-21-decrease-and-conquer.adoc[Decrease and Conquer 减治法]。在出现重复时，将后面的账户加入到前面账户。

|{counter:codes2503}
|{leetcode_base_url}/super-pow/[372. 超级次方^]
|{doc_base_url}/0372-super-pow.adoc[题解]
|⭕️ 数学计算+分治算法。重点是要搞清楚，两个数字相乘求模，等于分别对两个数求模，相乘然后再求模。最开始的想法把复杂度搞错了。通过 `a *= a` + `b /= 2` 可以对半减低计算幂次方的循环次数，也就可以大幅降低计算耗时。

|{counter:codes2503}
|{leetcode_base_url}/path-sum-ii/[113. Path Sum II^]
|{doc_base_url}/0113-path-sum-ii.adoc[题解]
|✅ 回溯。

|{counter:codes2503}
|{leetcode_base_url}/path-sum-iii/[437. 路径总和 III^]
|{doc_base_url}/0437-path-sum-iii.adoc[题解]
|✅ 回溯+前缀和。利用回溯，遍历所有节点；利用前缀和，来避免重复计算。

|{counter:codes2503}
|{leetcode_base_url}/generate-parentheses/[22. 括号生成^]
|{doc_base_url}/0022-generate-parentheses.adoc[题解]
|✅ 复习 {doc_base_url}/0000-25-subsets.adoc[Subsets 子集]。尝试子集模式的解法。有重复元素，利用 `Set` 去重。但是，这个办法不够通用。更通用的处理含重复元素的排列的子集模式，还需要再深入学习一下。🎯

|{counter:codes2503}
|{leetcode_base_url}/triangle/[120. 三角形最小路径和^]
|{doc_base_url}/0120-triangle.adoc[题解]
|✅ 动态规划。恰当的计算顺序对算法的实现也至关重要！

|{counter:codes2503}
|{leetcode_base_url}/count-ways-to-build-good-strings/[2466. 统计构造好字符串的方案数^]
|{doc_base_url}/2466-count-ways-to-build-good-strings.adoc[题解]
|❌ 动态规划。还是爬楼梯！

|{counter:codes2503}
|{leetcode_base_url}/house-robber-ii/[213. 打家劫舍 II^]
|{doc_base_url}/0213-house-robber-ii.adoc[题解]
|✅ 动态规划。从两端开始抢劫，最后剩余一个不抢。或者从第一抢到倒数第二个，或从第二个抢到最后一个。

|{counter:codes2503}
|{leetcode_base_url}/maximum-subarray/[53. 最大子数组和^]
|{doc_base_url}/0053-maximum-subarray.adoc[题解]
|✅ 动态规划。stem:[f(x)] 表示从 `0` 到第 `x` 个元素的最大子数组和，如果第 `x-1` 个元素的最大子数组之和大于 `0`，则可以继续向上“盖楼”；当小于等于 `0` 时，可以抛弃前面的元素从新开始。则递推公式是： stem:[f(x)=max(f(x-1),0)+a[x\]]。

|{counter:codes2503}
|{leetcode_base_url}/find-the-substring-with-maximum-cost/[2606. 找到最大开销的子字符串^]
|{doc_base_url}/2606-find-the-substring-with-maximum-cost.adoc[题解]
|✅ 动态规划。利用后两个参数加字母表，可以求出每个字母对应的价值。其余就是一个“最大子数组和”，直接利用 Kadane 算法即可。

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum/[931. 下降路径最小和^]
|{doc_base_url}/0931-minimum-falling-path-sum.adoc[题解]
|✅ 动态规划。状态转移可以视作在网格图上的移动。

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-moves-in-a-grid/[2684. 矩阵中移动的最大次数^]
|{doc_base_url}/2684-maximum-number-of-moves-in-a-grid.adoc[题解]
|✅ 动态规划。注意：是从左向右移动，不是从上向下移动。

|{counter:codes2503}
|{leetcode_base_url}/partition-equal-subset-sum/[416. 分割等和子集^]
|{doc_base_url}/0416-partition-equal-subset-sum.adoc[题解]
|❌ 动态规划。0/1 背包问题，有个大概思路，但是还不完善，代码也没写出来。`dp[i][j] = dp[i - 1][j] \|\| dp[i - 1][j - nums[i]]`，`dp[i][j]` 表示由 `nums[0~i]` 能否组成 `j`。

|{counter:codes2503}
|{leetcode_base_url}/coin-change/[322. 零钱兑换]
|{doc_base_url}/0322-coin-change.adoc[题解]
|✅ 动态规划。完全背包问题。`dp[i]` 表示组成金额 `i` 最少需要的零钱数量。外层遍历兑换金额，内层遍历零钱，零钱就可以取用多次，在零钱遍历过程中，找到所需最少的零钱数量。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-subsequence/[1143. 最长公共子序列^]
|{doc_base_url}/1143-longest-common-subsequence.adoc[题解]
|⭕️ 动态规划。有了大概思路，在思考递推公式时，搞错了。 stem:[dp[r\][c\]] 除了从 stem:[dp[r-1\][c-1\]+1] 来增大，还可以从 stem:[dp[r-1\][c\]] 或 stem:[dp[r\][c-1\]] 找找出最大值来继承。

|{counter:codes2503}
|{leetcode_base_url}/target-sum/[494. 目标和^]
|{doc_base_url}/0494-target-sum.adoc[题解]
|⭕️ 动态规划。可以通过 latexmath:[sum = positive + negative] 和 latexmath:[target = positive - negative] 解方程可以得到 latexmath:[positive = (sum + target) / 2] 和 latexmath:[negative = (sum - target) / 2]。那么，只需要从数字数组中挑选出一些元素使其等于 `positive` 或 `negative` 即可。这就转化成了一个 0/1 背包问题。

|{counter:codes2503}
|{leetcode_base_url}/partition-equal-subset-sum/[416. 分割等和子集^]
|{doc_base_url}/0416-partition-equal-subset-sum.adoc[题解]
|⭕️ 动态规划。对比 <<0000-26-dp-1-0-1-knapsack>> 与 <<0000-26-dp-2-unbounded-knapsack>> 的差异，验证 0/1 背包如何通过逆序遍历来解题。

|{counter:codes2503}
|{leetcode_base_url}/coin-change/[322. 零钱兑换]
|{doc_base_url}/0322-coin-change.adoc[题解]
|✅ 动态规划。对比 <<0000-26-dp-1-0-1-knapsack>> 与 <<0000-26-dp-2-unbounded-knapsack>> 的差异，验证完全背包如何通过正序遍历来解题。

|{counter:codes2503}
|{leetcode_base_url}/coin-change-ii/[518. 零钱兑换 II]
|{doc_base_url}/0518-coin-change-ii.adoc[题解]
|⭕️ 动态规划。用一维数组完成没问题；重现二维递推过程，懵逼了！还是得多想多练。

|{counter:codes2503}
|{leetcode_base_url}/rotting-oranges/[994. 腐烂的橘子^]
|{doc_base_url}/0994-rotting-oranges.adoc[题解]
|✅ 广度优先遍历。两种做法：①腐烂加深，从 `2` → `3` → ...，直到无法前进；②记录新鲜番茄数+腐烂番茄位置，对烂番茄做广度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/partition-labels/[763. 划分字母区间^]
|{doc_base_url}/0763-partition-labels.adoc[题解]
|✅ 区间合并。把有重叠的区间全部合并成一个大区间即可。

|{counter:codes2503}
|{leetcode_base_url}/daily-temperatures/[739. 每日温度^]
|{doc_base_url}/0739-daily-temperatures.adoc[题解]
|✅ 单调栈。从后向前，如果栈顶元素小于等于当前元素，则弹出。如果栈不为空，则栈顶元素就是比当前元素大的最近的元素。

|{counter:codes2503}
|{leetcode_base_url}/subarray-sum-equals-k/[560. 和为 K 的子数组^]
|{doc_base_url}/0560-subarray-sum-equals-k.adoc[题解]
|✅ 前缀和。由于有负数，使用双指针+滑动窗口无法缩放窗口的大小，所以，无法使用双指针。只能使用前缀和。需求在计数器里放一个前缀和为 `0` 的标识符。

|{counter:codes2503}
|{leetcode_base_url}/diameter-of-binary-tree/[543. 二叉树的直径^]
|{doc_base_url}/0543-diameter-of-binary-tree.adoc[题解]
|✅ 深度优先遍历。这道题求解的是“路径长度”，不是节点数量。理解这一点，就能理解当节点为 `Null` 时，不返回 `0` 而返回其他值，到上一层再 `+1`的含义。

|{counter:codes2503}
|{leetcode_base_url}/find-all-anagrams-in-a-string/[438. 找到字符串中所有字母异位词^]
|{doc_base_url}/0438-find-all-anagrams-in-a-string.adoc[题解]
|✅ 滑动窗口。

|{counter:codes2503}
|{leetcode_base_url}/path-sum-iii/[437. 路径总和 III^]
|{doc_base_url}/0437-path-sum-iii.adoc[题解]
|✅ 回溯+前缀和。利用回溯，遍历所有节点；利用前缀和，来避免重复计算。加一个 `<0, 1>` 的占位符，可以让代码写得更简洁。

|{counter:codes2503}
|{leetcode_base_url}/partition-equal-subset-sum/[416. 分割等和子集^]
|{doc_base_url}/0416-partition-equal-subset-sum.adoc[题解]
|✅ 动态规划。0/1 背包问题。直接上空间压缩的解法。

|{counter:codes2503}
|{leetcode_base_url}/decode-string/[394. 字符串解码^]
|{doc_base_url}/0394-decode-string.adoc[题解]
|✅ 使用递归模拟栈。递归一次，降维一层。

|{counter:codes2503}
|{leetcode_base_url}/top-k-frequent-elements/[347. 前 K 个高频元素^]
|{doc_base_url}/0347-top-k-frequent-elements.adoc[题解]
|⭕️ Top K 问题，优先队列，桶排序和快速选择。尝试快速选择，思路有，代码总报错。最后，无奈选择桶排序。

|{counter:codes2503}
|{leetcode_base_url}/longest-increasing-subsequence/[300. 最长递增子序列^]
|{doc_base_url}/0300-longest-increasing-subsequence.adoc[题解]
|⭕️ 动态规划。从原始数组克隆出一个去重后再排序的新数组，利用 {doc_base_url}/1143-longest-common-subsequence.adoc[1143. 最长公共子序列] 来求解。题目解出来了，还要学习一下更标准的解法。

|{counter:codes2503}
|{leetcode_base_url}/find-median-from-data-stream/[295. 数据流的中位数^]
|{doc_base_url}/0295-find-median-from-data-stream.adoc[题解]
|✅ 对顶堆。每次添加，都要在两个堆之间倒腾一下，保证小的沉下去，大的升上去。

|{counter:codes2503}
|{leetcode_base_url}/sliding-window-median/[480. 滑动窗口中位数^]
|{doc_base_url}/0480-sliding-window-median.adoc[题解]
|✅ 滑动窗口+对顶堆。在对顶堆的基础上，加上延迟删除技巧。所谓延迟删除技巧，就是只删除堆顶。这样，就不用耗时去堆里遍历查找要删除的元素。

|{counter:codes2503}
|{leetcode_base_url}/find-the-duplicate-number/[287. 寻找重复数^]
|{doc_base_url}/0287-find-the-duplicate-number.adoc[题解]
|⭕️ 快慢指针。利用 {doc_base_url}/0142-linked-list-cycle-ii.adoc[142. 环形链表 II^] 思路，将数组转换成一个找链表环的入口来解决。有机会试试循环排序的解法。

|{counter:codes2503}
|{leetcode_base_url}/move-zeroes/[283. 移动零^]
|{doc_base_url}/0283-move-zeroes.adoc[题解]
|✅ 快慢指针。看题解，本地栈解法更简洁。

|{counter:codes2503}
|{leetcode_base_url}/perfect-squares/[279. 完全平方数^]
|{doc_base_url}/0279-perfect-squares.adoc[题解]
|❌ 动态规划。完全背包问题。脑子里还是一堆浆糊，还是得练！

|{counter:codes2503}
|{leetcode_base_url}/search-a-2d-matrix-ii/[240. 搜索二维矩阵 II^]
|{doc_base_url}/0240-search-a-2d-matrix-ii.adoc[题解]
|❌ 双指针或贪心（看法各异）。不要有序就强上二分查找。观察矩阵，右上角和左下角的元素有代表性：根据大小，可以删除左边一列（大于等于右上角元素）或上一行（小于等于右上角元素），或者下面一行（大于等于左上角元素）或坐标一列（小于等于左下角元素）。可以根据这个规律，来排查不符合条件的元素。

|{counter:codes2503}
|{leetcode_base_url}/sliding-window-maximum/[239. 滑动窗口最大值^]
|{doc_base_url}/0239-sliding-window-maximum.adoc[题解]
|✅ 单调递减栈。把小的数字逐步弹出，只留下大的。如果滑出窗口，则把最底下的元素删除。

|{counter:codes2503}
|{leetcode_base_url}/product-of-array-except-self/[238. 除自身以外数组的乘积^]
|{doc_base_url}/0238-product-of-array-except-self.adoc[题解]
|✅ 前缀和。利用前缀和的思路，分别求前缀乘积和后缀乘积，然后再逐个求每个元素的前后元素乘积。利用结果数组存前缀乘积，可以将空间复杂度降低到常数级。

|{counter:codes2503}
|{leetcode_base_url}/lowest-common-ancestor-of-a-binary-tree/[236. 二叉树的最近公共祖先^]
|{doc_base_url}/0236-lowest-common-ancestor-of-a-binary-tree.adoc[题解]
|✅ 深度优先遍历。找到或者到叶子节点就“触底反弹”，在“后根遍历”的位置处理递归调用的结果，分属左右子树则返回“当前根节点”，否则谁不为空返回谁。

|{counter:codes2503}
|{leetcode_base_url}/palindrome-linked-list/[234. 回文链表^]
|{doc_base_url}/0234-palindrome-linked-list.adoc[题解]
|✅ 快慢指针。使用快慢指针找到中间节点，翻转后半部分，再和前半部分比较即可。

|{counter:codes2503}
|{leetcode_base_url}/kth-smallest-element-in-a-bst/[230. 二叉搜索树中第 K 小的元素^]
|{doc_base_url}/0230-kth-smallest-element-in-a-bst.adoc[题解]
|✅ DFS + 树。递归方式OK，迭代方式还要再体会一下。

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-right-side-view/[199. 二叉树的右视图^]
|{doc_base_url}/0199-binary-tree-right-side-view.adoc[题解]
|✅ 深度优先遍历。可以不用 `Map`，直接用 `List` 即可。要注意**先根遍历**和**中根遍历**的区别：先根遍历每层都是按顺序从上到下添加到 `List`；而中根遍历，每次都是最下层到，所以，要添加 `null` 占位符把 `List` 给撑起来，后续直接按照坐标设置。

|{counter:codes2503}
|{leetcode_base_url}/invert-binary-tree/[226. 翻转二叉树^]
|{doc_base_url}/0226-invert-binary-tree.adoc[题解]
|✅ 深度优先遍历或广度优先遍历。先递归再交换，或者先交换再递归。

|{counter:codes2503}
|{leetcode_base_url}/rotate-array/[189. 轮转数组^]
|{doc_base_url}/0189-rotate-array.adoc[题解]
|✅ 双指针。分成两段，分别首尾对调，再整体首尾对调。

|{counter:codes2503}
|{leetcode_base_url}/house-robber/[198. 打家劫舍^]
|{doc_base_url}/0198-house-robber.adoc[题解]
|✅ 动态规划。如果利用数组，则需要修正 `nums[1]` 的值，使其符合 `nums[i]` 是 `0~i` 元素中最大抢劫金额

|{counter:codes2503}
|{leetcode_base_url}/majority-element/[169. 多数元素^]
|{doc_base_url}/0169-majority-element.adoc[题解]
|✅ 数学。哈希，排序取中位数等。摩尔投票法还要多学习。

|{counter:codes2503}
|{leetcode_base_url}/intersection-of-two-linked-lists/[160. 相交链表^]
|{doc_base_url}/0160-intersection-of-two-linked-lists.adoc[题解]
|✅ 双指针。链表 `x+z` 和 `y+z`，两个链表拼接，则是 `(x+z+y)+z` 和 `(y+z+x)+z`，就可以通过相同的步数找到最后的共同部分 `z`。

|{counter:codes2503}
|{leetcode_base_url}/min-stack/[155. 最小栈^]
|{doc_base_url}/0155-min-stack.adoc[题解]
|✅ 栈。可以使用一个辅助栈存最小值；也可以把最小值和当前值作为一个数对存入栈中，这样只需要一个栈。

|===

截止目前，本轮练习一共完成 {codes2503} 道题。
