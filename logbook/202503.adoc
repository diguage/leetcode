[#logbook-202503]
= 2025年03月 刷题日志
ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]


[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|⭕️ 递归解法非常妙！传一个参数，`next` 又 `next` 比较麻烦，传两个参数比较简单。

|{counter:codes2503}
|{leetcode_base_url}/find-first-and-last-position-of-element-in-sorted-array/[34. 在排序数组中查找元素的第一个和最后一个位置^]
|{doc_base_url}/0034-find-first-and-last-position-of-element-in-sorted-array.adoc[题解]
|✅ 思考清楚确定边界时，中间指针的移动方向即可迎刃而解。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点去处理有序部分，在有序部分内查找不到，则去另外一部分去查找。

|{counter:codes2503}
|{leetcode_base_url}/merge-intervals/[56. 合并区间^]
|{doc_base_url}/0056-merge-intervals.adoc[题解]
|✅ 对区间进行排序，然后快慢指针在当前数组上对其进行合并。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array-ii/[81. 搜索旋转排序数组 II^]
|{doc_base_url}/0081-search-in-rotated-sorted-array-ii.adoc[题解]
|✅ 关注有序区间，确定目标值在有序区间内，则在有序区间查找；反之，则在另外一部分内查找。另外，通过移动一个指针即可避开重复元素。

|{counter:codes2503}
|{leetcode_base_url}/two-sum/[1. 两数之和^]
|{doc_base_url}/0001-two-sum.adoc[题解]
|✅ 注意审题！返回的是数组下标。

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle/[141. 环形链表^]
|{doc_base_url}/0141-linked-list-cycle.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/happy-number/[202. 快乐数^]
|{doc_base_url}/0202-happy-number.adoc[题解]
|✅ 快慢指针

|{counter:codes2503}
|{leetcode_base_url}/minimum-window-substring/[76. 最小覆盖子串^]
|{doc_base_url}/0076-minimum-window-substring.adoc[题解]
|⭕️ 滑动窗口，一定注意细节的处理。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicate-letters/[316. 去除重复字母^]
|{doc_base_url}/0316-remove-duplicate-letters.adoc[题解]
|❌ 完全想不到单调栈！

|{counter:codes2503}
|{leetcode_base_url}/top-k-frequent-elements/[347. 前 K 个高频元素^]
|{doc_base_url}/0347-top-k-frequent-elements.adoc[题解]
|✅ Top K 问题，优先队列；桶排序

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|⭕️ 快速选择，想清楚边界情况！

|{counter:codes2503}
|{leetcode_base_url}/first-missing-positive/[41. 缺失的第一个正数^]
|{doc_base_url}/0041-first-missing-positive.adoc[题解]
|⭕️ 循环排序，看了答案，自己写出来了。

|{counter:codes2503}
|{leetcode_base_url}/find-median-from-data-stream/[295. 数据流的中位数^]
|{doc_base_url}/0295-find-median-from-data-stream.adoc[题解]
|⭕️ 双堆，思路理解，写代码却有很多问题。

|{counter:codes2503}
|{leetcode_base_url}/merge-k-sorted-lists/[23. 合并 K 个升序链表^]
|{doc_base_url}/0023-merge-k-sorted-lists.adoc[题解]
|✅ 多路归并

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-level-order-traversal/[102. 二叉树的层序遍历^]
|{doc_base_url}/0102-binary-tree-level-order-traversal.adoc[题解]
|✅ 广度优先搜索

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-maximum-path-sum/[124. 二叉树中的最大路径和^]
|{doc_base_url}/0124-binary-tree-maximum-path-sum.adoc[题解]
|⭕️ 深度优先搜索，注意处理负数情况

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-without-repeating-characters/[3. 无重复字符的最长子串^]
|{doc_base_url}/0003-longest-substring-without-repeating-characters.adoc[题解]
|✅ 滑动窗口

|{counter:codes2503}
|{leetcode_base_url}/lru-cache/[146. LRU 缓存^]
|{doc_base_url}/0146-lru-cache.adoc[题解]
|✅ 链表前后指针操作

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list/[206. 反转链表^]
|{doc_base_url}/0206-reverse-linked-list.adoc[题解]
|✅ 两种解法：递归+迭代

|{counter:codes2503}
|{leetcode_base_url}/kth-largest-element-in-an-array/[215. 数组中的第K个最大元素^]
|{doc_base_url}/0215-kth-largest-element-in-an-array.adoc[题解]
|✅ 快速选择

|{counter:codes2503}
|{leetcode_base_url}/reverse-nodes-in-k-group/[25. K 个一组翻转链表^]
|{doc_base_url}/0025-reverse-nodes-in-k-group.adoc[题解]
|✅ 分段递归反转，再拼接

|{counter:codes2503}
|{leetcode_base_url}/implement-trie-prefix-tree/[208. 实现 Trie (前缀树)^]
|{doc_base_url}/0208-implement-trie-prefix-tree.adoc[题解]
|✅ 前缀树，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/number-of-provinces/[547. 省份数量]
|{doc_base_url}/0547-number-of-provinces.adoc[题解]
|✅ 并查集，竟然一次通过

|{counter:codes2503}
|{leetcode_base_url}/3sum/[15. 三数之和^]
|{doc_base_url}/0015-3sum.adoc[题解]
|✅ 利用递归“降维”

|{counter:codes2503}
|{leetcode_base_url}/course-schedule/[207. 课程表^]
|{doc_base_url}/0207-course-schedule.adoc[题解]
|✅ 拓扑排序

|{counter:codes2503}
|{leetcode_base_url}/maximum-subarray/[53. 最大子数组和^]
|{doc_base_url}/0053-maximum-subarray.adoc[题解]
|⭕️ 动态规划。稀里糊涂就对了，还要对推演。另有更精妙的分治解法，抽空再尝试。

|{counter:codes2503}
|{leetcode_base_url}/merge-two-sorted-lists/[21. 合并两个有序链表^]
|{doc_base_url}/0021-merge-two-sorted-lists.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-substring/[5. 最长回文子串^]
|{doc_base_url}/0005-longest-palindromic-substring.adoc[题解]
|✅ 有更高效的马拉车算法，抽空可以尝试一下。

|{counter:codes2503}
|{leetcode_base_url}/search-in-rotated-sorted-array/[33. 搜索旋转排序数组^]
|{doc_base_url}/0033-search-in-rotated-sorted-array.adoc[题解]
|⭕️ 重点关注有序部分，优先在有序部分查找，不在有序部分再去无序部分查找。注意判定有序部分的方法： `nums[0]` 与 `nums[mid]` 相比较，而不是 `nums[left]`（它的值会来回变）。

|{counter:codes2503}
|{leetcode_base_url}/number-of-islands/[200. 岛屿数量^]
|{doc_base_url}/0200-number-of-islands.adoc[题解]
|✅ 想尝试并查集，结果失败。还是沉岛大法好啊！

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/power-of-two/[231. 2 的幂^]
|{doc_base_url}/0231-power-of-two.adoc[题解]
|✅ 更巧妙的解法是位运算，如果 `n` 是 `2` 的幂，则二进制只有第一位是 `1`，减一则二进制都是 `1`，相与 `n & (n - 1)` 则为 `0`。

|{counter:codes2503}
|{leetcode_base_url}/merge-sorted-array/[88. 合并两个有序数组^]
|{doc_base_url}/0088-merge-sorted-array.adoc[题解]
|✅ `num1` 后面空着，则从后向前合并。

|{counter:codes2503}
|{leetcode_base_url}/powx-n/[50. Pow(x, n)^]
|{doc_base_url}/0050-powx-n.adoc[题解]
|✅ 递归很简单，抽空再思考一下非递归形式。

|{counter:codes2503}
|{leetcode_base_url}/sort-list/[148. 排序链表]
|{doc_base_url}/0148-sort-list.adoc[题解]
|✅ 分治

|{counter:codes2503}
|{leetcode_base_url}/ones-and-zeroes/[474. 一和零^]
|{doc_base_url}/0474-ones-and-zeroes.adoc[题解]
|❌ 动态规划，多维度“物品”就无从下手，还要多练。

|{counter:codes2503}
|{leetcode_base_url}/coin-change/[322. 零钱兑换]
|{doc_base_url}/0322-coin-change.adoc[题解]
|⭕️ 动态规划，完全背包问题

|{counter:codes2503}
|{leetcode_base_url}/subsets-ii/[90. 子集 II]
|{doc_base_url}/0090-subsets-ii.adoc[题解]
|⭕️ 子集，需要注意重复元素的处理。现在用 `Set` 记录已添加子集的方案还可以再优化。添加优化解法。

|{counter:codes2503}
|{leetcode_base_url}/permutations/[46. 全排列^]
|{doc_base_url}/0046-permutations.adoc[题解]
|✅ 子集。注意对比子集模式在处理子集和排列时的不同：①子集直接在结果中添加新子集；②排列则是将结果中的元素出队，添加新元素后，再入队。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock/[121. 买卖股票的最佳时机^]
|{doc_base_url}/0121-best-time-to-buy-and-sell-stock.adoc[题解]
|✅ 遍历找最大差值

|{counter:codes2503}
|{leetcode_base_url}/lowest-common-ancestor-of-a-binary-tree/[236. 二叉树的最近公共祖先^]
|{doc_base_url}/0236-lowest-common-ancestor-of-a-binary-tree.adoc[题解]
|✅ 递归遍历查找目标节点，找到则返回，找不到则返回 `null`，当左右都不是 `null` 时，则当前节点即是最近公共祖先。

|{counter:codes2503}
|{leetcode_base_url}/reverse-linked-list-ii/[92. 反转链表 II^]
|{doc_base_url}/0092-reverse-linked-list-ii.adoc[题解]
|✅ 链表反转

|{counter:codes2503}
|{leetcode_base_url}/find-the-index-of-the-first-occurrence-in-a-string/[28. 找出字符串中第一个匹配项的下标]
|{doc_base_url}/0028-find-the-index-of-the-first-occurrence-in-a-string.adoc[题解]
|✅ 暴力破解。更有的解法是 KMP 算法、Boyer-Moore 算法、Sunday 算法等算法。

|{counter:codes2503}
|{leetcode_base_url}/spiral-matrix/[54. Spiral Matrix^]
|{doc_base_url}/0054-spiral-matrix.adoc[题解]
|✅ 使用递归来推进层级。注意处理细节。另外，在“上”和“右”能覆盖“全部”（比如一行多列或者多行一列）时，才能在“下”之前根据长度返回。尝试了每段“读取”只剩一个的方案，不行，有很多意外情况要处理。

|{counter:codes2503}
|{leetcode_base_url}/add-strings/[415. 字符串相加^]
|{doc_base_url}/0415-add-strings.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/reorder-list/[143. Reorder List^]
|{doc_base_url}/0143-reorder-list.adoc[题解]
|✅ 双指针+链表反正+链表合并

|{counter:codes2503}
|{leetcode_base_url}/linked-list-cycle-ii/[142. 环形链表 II^]
|{doc_base_url}/0142-linked-list-cycle-ii.adoc[题解]
|✅ 双指针+数学

|{counter:codes2503}
|{leetcode_base_url}/remove-nth-node-from-end-of-list/[19. 删除链表的倒数第 N 个结点^]
|{doc_base_url}/0019-remove-nth-node-from-end-of-list.adoc[题解]
|✅ 双指针+虚拟头节点。使用虚拟头结点会省事好多。

|{counter:codes2503}
|{leetcode_base_url}/restore-ip-addresses/[93. 复原 IP 地址^]
|{doc_base_url}/0093-restore-ip-addresses.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/n-th-tribonacci-number/[1137. 第 N 个泰波那契数^]
|{doc_base_url}/1137-n-th-tribonacci-number.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber/[198. 打家劫舍^]
|{doc_base_url}/0198-house-robber.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-ii/[213. 打家劫舍 II^]
|{doc_base_url}/0213-house-robber-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iii/[337. 打家劫舍 III^]
|{doc_base_url}/0337-house-robber-iii.adoc[题解]
|✅ 动态规划+树 = 树形动态规划

|{counter:codes2503}
|{leetcode_base_url}/house-robber-iv/[2560. 打家劫舍 IV^]
|{doc_base_url}/2560-house-robber-iv.adoc[题解]
|❌ 看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/delete-and-earn/[740. 删除并获得点数^]
|{doc_base_url}/0740-delete-and-earn.adoc[题解]
|❌ 把题目理解错了。处理后就是最简单的打家劫舍问题。

|{counter:codes2503}
|{leetcode_base_url}/unique-paths/[62. 不同路径^]
|{doc_base_url}/0062-unique-paths.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-ii/[63. 不同路径 II^]
|{doc_base_url}/0063-unique-paths-ii.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/unique-paths-iii/[980. 不同路径 III^]
|{doc_base_url}/0980-unique-paths-iii.adoc[题解]
|❌ 明知是回溯，但在处理当前节点时，总把当前和下一步混在一起。有思路，没写出代码。

|{counter:codes2503}
|{leetcode_base_url}/minimum-path-sum/[64. 最小路径和^]
|{doc_base_url}/0064-minimum-path-sum.adoc[题解]
|✅ 动态规划。直接在原有矩阵上操作即可。

|{counter:codes2503}
|{leetcode_base_url}/triangle/[120. 三角形最小路径和^]
|{doc_base_url}/0120-triangle.adoc[题解]
|✅ 动态规划。从底向上比从上向底效率更高。

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum/[931. 下降路径最小和^]
|{doc_base_url}/0931-minimum-falling-path-sum.adoc[题解]
|✅ 动态规划

|{counter:codes2503}
|{leetcode_base_url}/minimum-falling-path-sum-ii/[1289. 下降路径最小和  II^]
|{doc_base_url}/1289-minimum-falling-path-sum-ii.adoc[题解]
|⭕️ 动态规划。题目理解错误。

|{counter:codes2503}
|{leetcode_base_url}/maximal-square/[221. 最大正方形^]
|{doc_base_url}/0221-maximal-square.adoc[题解]
|✅ 动态规划。直接将结果存储在参数矩阵上。如果正方形想扩大，则左边，左上和上面三个都是正方形时才可以，可以直接去这三者中的最小值。

|{counter:codes2503}
|{leetcode_base_url}/word-break/[139. 单词拆分^]
|{doc_base_url}/0139-word-break.adoc[题解]
|⭕️ 回溯+备忘录。首先想到的是回溯，但是超时（通过34/47的测试用例）。参考别人题解后，得到启发，加上备忘录通过。参考答案写出了动态规划的解法。*思考如何从基于回溯+备忘录转变为动态规划？*

|{counter:codes2503}
|{leetcode_base_url}/word-break-ii/[140. 单词拆分 II^]
|{doc_base_url}/0140-word-break-ii.adoc[题解]
|✅ 回溯。没想到从 `LinkedList` 切换到 `ArrayList`，内存占用就大幅下降 43.77% → 91.82%。没有使用备忘录耗时已经击败了 98.49%。

|{counter:codes2503}
|{leetcode_base_url}/longest-palindromic-subsequence/[516. 最长回文子序列^]
|{doc_base_url}/0516-longest-palindromic-subsequence.adoc[题解]
|❌ 动态规划。相当于在“结尾”中寻找回文子串。从一维字符串字符坐标去看转移方程，会更加清楚明了。

|{counter:codes2503}
|{leetcode_base_url}/container-with-most-water/[11. 盛最多水的容器^]
|{doc_base_url}/0011-container-with-most-water.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/remove-element/[27. 移除元素^]
|{doc_base_url}/0027-remove-element.adoc[题解]
|✅ 快慢指针。慢指针记录满足条件的长度，快指针指向需要处理的元素。

|{counter:codes2503}
|{leetcode_base_url}/trapping-rain-water/[42. 接雨水^]
|{doc_base_url}/0042-trapping-rain-water.adoc[题解]
|❌ 使用单调栈没写出来。使用单调栈，需 `h × w`，不能只看头顶的容量。使用左右双指针夹逼代码更简单，只需要计算头顶的容量即可。

|{counter:codes2503}
|{leetcode_base_url}/edit-distance/[72. 编辑距离^]
|{doc_base_url}/0072-edit-distance.adoc[题解]
|✅ 动态规划。思考如何进一步优化成一维数组？

|{counter:codes2503}
|{leetcode_base_url}/maximum-width-of-binary-tree/[662. 二叉树最大宽度^]
|{doc_base_url}/0662-maximum-width-of-binary-tree.adoc[题解]
|⭕️ 添加虚拟节点的做法超时。看答案给节点加编号通过。

|{counter:codes2503}
|{leetcode_base_url}/next-permutation/[31. 下一个排列^]
|{doc_base_url}/0031-next-permutation.adoc[题解]
|❌ 明白大概意思，思路不够条理，写不出代码。

|{counter:codes2503}
|{leetcode_base_url}/rotate-array/[189. 轮转数组^]
|{doc_base_url}/0189-rotate-array.adoc[题解]
|❌ 题目理解错误，是轮转数组，不是旋转数组。

|{counter:codes2503}
|{leetcode_base_url}/remove-linked-list-elements/[203. 移除链表元素^]
|{doc_base_url}/0203-remove-linked-list-elements.adoc[题解]
|✅ 快慢指针。看答案，一个指针也可以！而且代码更简单！

|{counter:codes2503}
|{leetcode_base_url}/maximum-length-of-repeated-subarray/[718. 最长重复子数组^]
|{doc_base_url}/0718-maximum-length-of-repeated-subarray.adoc[题解]
|❌ 动态规划。这里求的是公共子数组，只能在两个字符相等时，在上一个字符的基础上加 `1`，否则就应该设置为 `0`。不能取 `min{dp[i-1][j], dp[i][j-1]}`。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-subsequence/[1143. 最长公共子序列^]
|{doc_base_url}/1143-longest-common-subsequence.adoc[题解]
|✅ 动态规划。注意区分“子序列”和“子数组”的区别。

|{counter:codes2503}
|{leetcode_base_url}/minimum-size-subarray-sum/[209. 长度最小的子数组^]
|{doc_base_url}/0209-minimum-size-subarray-sum.adoc[题解]
|✅ 滑动窗口。没想到队列也能当滑动窗口。

|{counter:codes2503}
|{leetcode_base_url}/palindrome-partitioning/[131. Palindrome Partitioning^]
|{doc_base_url}/0131-palindrome-partitioning.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/accounts-merge/[721. 账户合并^]
|{doc_base_url}/0721-accounts-merge.adoc[题解]
|❌ 并查集。通过邮箱编号建立连接，而不是通过账户索引建立连接。

|{counter:codes2503}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|⭕️ 最初思路是排序。看答案，可以构建集合，然后“起点”（没有前一个数字）数字开始统计。

|{counter:codes2503}
|{leetcode_base_url}/design-linked-list/[707. 设计链表^]
|{doc_base_url}/0707-design-linked-list.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|❌ 单调栈，与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. Remove Duplicate Letters] 相同。知道用单调栈，但还是没写出来。

|{counter:codes2503}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。看答案也一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/minimum-absolute-difference-in-bst/[530. 二叉搜索树的最小绝对差^]
|{doc_base_url}/0530-minimum-absolute-difference-in-bst.adoc[题解]
|✅ 二叉树中根遍历。

|{counter:codes2503}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|⭕️ 回溯。找出所有的高峰和山谷，然后对高峰做排列，计算各种排列与山谷的距离，取最小值即可。有模糊思路，看答案才写出代码。

|{counter:codes2503}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。要分情况处理窗口移动问题。

|{counter:codes2503}
|{leetcode_base_url}/longest-valid-parentheses/[32. 最长有效括号^]
|{doc_base_url}/0032-longest-valid-parentheses.adoc[题解]
|⭕️ 栈。使用栈记录左右括号的下标，匹配后标注“占位符”。最后，统计占位符中的数量，找出最大长度。

|{counter:codes2503}
|{leetcode_base_url}/search-a-2d-matrix/[74. 搜索二维矩阵^]
|{doc_base_url}/0074-search-a-2d-matrix.adoc[题解]
|✅ 二分查找。把矩阵按行“拼接”，然后二分查找，解法非常妙。

|{counter:codes2503}
|{leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^]
|{doc_base_url}/0084-largest-rectangle-in-histogram.adoc[题解]
|❌ 单调栈。一脸懵逼。哨兵技巧非常巧妙。

|{counter:codes2503}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string/[1047. 删除字符串中的所有相邻重复项^]
|{doc_base_url}/1047-remove-all-adjacent-duplicates-in-string.adoc[题解]
|⭕️ 栈。把 `StringBuilder` 当做栈来使用。将最后一个字符与当前字符比较，相等则删除最后一个字符，否则就添加。

|{counter:codes2503}
|{leetcode_base_url}/last-stone-weight-ii/[1049. 最后一块石头的重量 II^]
|{doc_base_url}/1049-last-stone-weight-ii.adoc[题解]
|❌ 动态规划，0/1 背包问题。一脸懵逼。

|{counter:codes2503}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|⭕️ 回溯。学习使用位操作来标注已用字符，计算未用字符。位操作真是太玄妙了！

|{counter:codes2503}
|{leetcode_base_url}/combination-sum/[39. 组合总和^]
|{doc_base_url}/0039-combination-sum.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-ii/[40. 组合总和 II^]
|{doc_base_url}/0040-combination-sum-ii.adoc[题解]
|✅ 回溯。注意同层剪枝的技巧。

|{counter:codes2503}
|{leetcode_base_url}/rotate-image/[48. 旋转图像^]
|{doc_base_url}/0048-rotate-image.adoc[题解]
|✅ 使用递归来推进循环。

|{counter:codes2503}
|{leetcode_base_url}/group-anagrams/[49. 字母异位词分组^]
|{doc_base_url}/0049-group-anagrams.adoc[题解]
|✅ 使用 `Map` 存字符和数量即可。

|{counter:codes2503}
|{leetcode_base_url}/subarray-sum-equals-k/[560. 和为 K 的子数组^]
|{doc_base_url}/0560-subarray-sum-equals-k.adoc[题解]
|✅ 前缀和。需要记录每一个和的出现次数。

|{counter:codes2503}
|{leetcode_base_url}/sqrtx/[69. x 的平方根^]
|{doc_base_url}/0069-sqrtx.adoc[题解]
|✅ 二分查找。使用一个单独变量来保存最后一个小于等于的中间值，那么即可直接获取答案。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-ii/[122. 买卖股票的最佳时机 II^]
|{doc_base_url}/0122-best-time-to-buy-and-sell-stock-ii.adoc[题解]
|✅ 有差价就买卖，见好就收。

|{counter:codes2503}
|{leetcode_base_url}/valid-palindrome/[125. 验证回文串^]
|{doc_base_url}/0125-valid-palindrome.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/single-number/[136. 只出现一次的数字^]
|{doc_base_url}/0136-single-number.adoc[题解]
|✅ 位运算。出现两次，则异或后为 `0`，所有数字异或，最后只剩下出现一次的数字。

|{counter:codes2503}
|{leetcode_base_url}/dota2-senate/[649. Dota2 参议院^]
|{doc_base_url}/0649-dota2-senate.adoc[题解]
|✅ 贪心算法。优先禁止最近的对方议员投票。不停循环，直到只留下一方议员。

|{counter:codes2503}
|{leetcode_base_url}/maximum-swap/[670. 最大交换^]
|{doc_base_url}/0670-maximum-swap.adoc[题解]
|✅ 贪心算法。最高位尽可能跟后面的最大数字进行交换。

|{counter:codes2503}
|{leetcode_base_url}/two-sum-ii-input-array-is-sorted/[167. 两数之和 II - 输入有序数组^]
|{doc_base_url}/0167-two-sum-ii-input-array-is-sorted.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/degree-of-an-array/[697. 数组的度^]
|{doc_base_url}/0697-degree-of-an-array.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/design-add-and-search-words-data-structure/[211. 添加与搜索单词 - 数据结构设计]
|{doc_base_url}/0211-design-add-and-search-words-data-structure.adoc[题解]
|✅ 前缀树。需要处理通配符的情况，尤其要注意结尾字符的处理。

|{counter:codes2503}
|{leetcode_base_url}/combination-sum-iii/[216. 组合总和 III^]
|{doc_base_url}/0216-combination-sum-iii.adoc[题解]
|✅ 回溯

|{counter:codes2503}
|{leetcode_base_url}/basic-calculator/[224. 基本计算器^]
|{doc_base_url}/0224-basic-calculator.adoc[题解]
|❌ 使用双栈来分别存放数字和操作符。

|{counter:codes2503}
|{leetcode_base_url}/sliding-window-maximum/[239. 滑动窗口最大值^]
|{doc_base_url}/0239-sliding-window-maximum.adoc[题解]
|✅ 单调栈。有很多细节需要考虑。

|{counter:codes2503}
|{leetcode_base_url}/single-number-iii/[260. 只出现一次的数字 III^]
|{doc_base_url}/0260-single-number-iii.adoc[题解]
|⭕️ 在 {doc_base_url}/0136-single-number.adoc[136. 只出现一次的数字] 基础上，做了进一步延伸。需要先根据所有数异或值的最后一位 `1`，将数字分为两部分，再分别做异或。

|{counter:codes2503}
|{leetcode_base_url}/single-number-ii/[137. 只出现一次的数字 II^]
|{doc_base_url}/0137-single-number-ii.adoc[题解]
|❌ 位运算。按位统计 `1` 出现的次数，取余留下来的则是 只出现一次的数字所拥有的 `1`，然后再做运算恢复成原始数字即可。

|{counter:codes2503}
|{leetcode_base_url}/distinct-subsequences/[115. 不同的子序列^]
|{doc_base_url}/0115-distinct-subsequences.adoc[题解]
|❌ 动态规划。

|{counter:codes2503}
|{leetcode_base_url}/number-of-good-leaf-nodes-pairs/[1530. 好叶子节点对的数量^]
|{doc_base_url}/1530-number-of-good-leaf-nodes-pairs.adoc[题解]
|⭕️ 还有瑕疵，还需要继续优化。

|{counter:codes2503}
|{leetcode_base_url}/remove-zero-sum-consecutive-nodes-from-linked-list/[1171. 从链表中删去总和值为零的连续节点^]
|{doc_base_url}/1171-remove-zero-sum-consecutive-nodes-from-linked-list.adoc[题解]
|❌ 前缀和。想到了前缀和，但是没想到可以利用中间和为 `0`，直接跳过这部分节点。

|{counter:codes2503}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-iii/[123. 买卖股票的最佳时机 III^]
|{doc_base_url}/0123-best-time-to-buy-and-sell-stock-iii.adoc[题解]
|❌ 动态规划。思路还需要多揣摩和思考。

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-right-side-view/[199. 二叉树的右视图^]
|{doc_base_url}/0199-binary-tree-right-side-view.adoc[题解]
|✅ 深度优先遍历。按照 `<level, node>` 的格式，把每个节点都放到 `Map` 里，因为是先左后右，所以，每层最后只剩下了最右边的元素。

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-moves-in-a-grid/[2684. 矩阵中移动的最大次数^]
|{doc_base_url}/2684-maximum-number-of-moves-in-a-grid.adoc[题解]
|✅ 动态规划。也可以使用深度优先搜索的解法，使用深度优先搜索时，需要把处理过的节点值设置为 `0`，防止重新判断，加快处理速度。

|{counter:codes2503}
|{leetcode_base_url}/cheapest-flights-within-k-stops/[787. K 站中转内最便宜的航班^]
|{doc_base_url}/0787-cheapest-flights-within-k-stops.adoc[题解]
|⭕️ 深度优先搜索通过 48 / 56 个测试用例。使用带备忘录的深度优先搜索顺利通过。带备忘录的深度优先搜索，也可以优化成动态规划。

|{counter:codes2503}
|{leetcode_base_url}/valid-tic-tac-toe-state/[794. 有效的井字游戏^]
|{doc_base_url}/0794-valid-tic-tac-toe-state.adoc[题解]
|✅ 总结提炼判断规则。

|{counter:codes2503}
|{leetcode_base_url}/harshad-number/[3099. 哈沙德数^]
|{doc_base_url}/3099-harshad-number.adoc[题解]
|✅ 数学计算

|{counter:codes2503}
|{leetcode_base_url}/longest-increasing-subsequence/[300. 最长递增子序列^]
|{doc_base_url}/0300-longest-increasing-subsequence.adoc[题解]
|❌ 动态规划。动态规划+二分查找的解法一脸懵逼，看答案都懵逼！

|{counter:codes2503}
|{leetcode_base_url}/binary-tree-preorder-traversal/[144. 二叉树的前序遍历^]
|{doc_base_url}/0144-binary-tree-preorder-traversal.adoc[题解]
|✅ 树的 Morris 遍历

|{counter:codes2503}
|{leetcode_base_url}/maximum-prime-difference/[3115. 质数的最大距离^]
|{doc_base_url}/3115-maximum-prime-difference.adoc[题解]
|✅ 质数判断

|{counter:codes2503}
|{leetcode_base_url}/design-hashset/[705. 设计哈希集合^]
|{doc_base_url}/0705-design-hashset.adoc[题解]
|✅ 使用开放地址法解决哈希冲突。

|{counter:codes2503}
|{leetcode_base_url}/shortest-string-that-contains-three-strings/[2800. 包含三个字符串的最短字符串^]
|{doc_base_url}/2800-shortest-string-that-contains-three-strings.adoc[题解]
|❌ 先求三个字符串的全排列，然后合并（合并时注意处理首尾相同子串，减少合并字符串的长度），在这些合并后的字符串中选择最短，字典排序最小的字符串。

|{counter:codes2503}
|{leetcode_base_url}/count-number-of-ways-to-place-houses/[2320. 统计放置房子的方式数^]
|{doc_base_url}/2320-count-number-of-ways-to-place-houses.adoc[题解]
|❌ 先只考虑一边的情况，再组合两边的情况。只考虑一边的情况，就是一个斐波那契数列： stem:[f(i) = f(i-1) + f(i-2)]。

|{counter:codes2503}
|{leetcode_base_url}/minimum-number-of-operations-to-move-all-balls-to-each-box/[1769. 移动所有球到每个盒子所需的最小操作数^]
|{doc_base_url}/1769-minimum-number-of-operations-to-move-all-balls-to-each-box.adoc[题解]
|✅ 最简单的解法双重循环。取巧的解法是，利用“前缀和”的思路，分别计算当前节点左右两侧的操作次数，然后再相加。

|{counter:codes2503}
|{leetcode_base_url}/intersection-of-two-arrays-ii/[350. 两个数组的交集 II^]
|{doc_base_url}/0350-intersection-of-two-arrays-ii.adoc[题解]
|✅ 最初思路是对两个数组统计次数。其实只需要对一个数组统计次数，另外一个数组遍历时就可以求交集了。

|{counter:codes2503}
|{leetcode_base_url}/is-subsequence/[392. 判断子序列^]
|{doc_base_url}/0392-is-subsequence.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/longest-palindrome/[409. 最长回文串^]
|{doc_base_url}/0409-longest-palindrome.adoc[题解]
|✅ 回文

|{counter:codes2503}
|{leetcode_base_url}/longest-substring-of-all-vowels-in-order/[1839. 所有元音按顺序排布的最长子字符串^]
|{doc_base_url}/1839-longest-substring-of-all-vowels-in-order.adoc[题解]
|✅ 滑动窗口。题目不难，只是处理边界条件麻烦。另外，也有取巧解法，可以探索一下。

|{counter:codes2503}
|{leetcode_base_url}/maximum-sum-circular-subarray/[918. 环形子数组的最大和^]
|{doc_base_url}/0918-maximum-sum-circular-subarray.adoc[题解]
|❌ 理解错题目了。前大，中小，后大，这类子数组也可以产生更多的子数组和。另有“取反”和单调栈解法。

|{counter:codes2503}
|{leetcode_base_url}/maximum-students-taking-exam/[1349. 参加考试的最大学生数^]
|{doc_base_url}/1349-maximum-students-taking-exam.adoc[题解]
|❌ 回溯解法通过 50 / 57 个测试用例。动态规划解法太难了！

|{counter:codes2503}
|{leetcode_base_url}/rotting-oranges/[994. 腐烂的橘子^]
|{doc_base_url}/0994-rotting-oranges.adoc[题解]
|✅ 腐烂加剧+传染。广度优先遍历的解法也挺有意思。

|{counter:codes2503}
|{leetcode_base_url}/longest-common-prefix/[14. 最长公共前缀^]
|{doc_base_url}/0014-longest-common-prefix.adoc[题解]
|✅ 解法很多，可以很好地开阔思路！

|{counter:codes2503}
|{leetcode_base_url}/generate-parentheses/[22. 括号生成^]
|{doc_base_url}/0022-generate-parentheses.adoc[题解]
|✅ 回溯。也可以去掉回溯过程，使用深度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/swap-nodes-in-pairs/[24. 两两交换链表中的节点^]
|{doc_base_url}/0024-swap-nodes-in-pairs.adoc[题解]
|✅ 链表。增加虚拟节点，极大简化代码。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-array/[26. 删除有序数组中的重复项^]
|{doc_base_url}/0026-remove-duplicates-from-sorted-array.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/jump-game-ii/[45. 跳跃游戏 II^]
|{doc_base_url}/0045-jump-game-ii.adoc[题解]
|✅ 贪心算法。也可以动态规划。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-array-ii/[80. 删除有序数组中的重复项 II^]
|{doc_base_url}/0080-remove-duplicates-from-sorted-array-ii.adoc[题解]
|✅ 双指针，同时需要记录每个元素的次数，相同元素只复制两个。

|{counter:codes2503}
|{leetcode_base_url}/jump-game/[55. 跳跃游戏^]
|{doc_base_url}/0055-jump-game.adoc[题解]
|✅ 贪心算法。没想到这就是贪心？

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-list-ii/[82. 删除排序链表中的重复元素 II^]
|{doc_base_url}/0082-remove-duplicates-from-sorted-list-ii.adoc[题解]
|✅ 快慢指针。

|{counter:codes2503}
|{leetcode_base_url}/remove-duplicates-from-sorted-list/[83. 删除排序链表中的重复元素^]
|{doc_base_url}/0083-remove-duplicates-from-sorted-list.adoc[题解]
|✅ 链表操作

|{counter:codes2503}
|{leetcode_base_url}/decode-ways/[91. 解码方法^]
|{doc_base_url}/0091-decode-ways.adoc[题解]
|❌ 动态规划。递推公式还要仔细推敲。

|{counter:codes2503}
|{leetcode_base_url}/check-if-matrix-is-x-matrix/[2319. 判断矩阵是否是一个 X 矩阵^]
|{doc_base_url}/2319-check-if-matrix-is-x-matrix.adoc[题解]
|✅ 遍历对角线设置成负值，检查其他元素，发现有大于 `0` 的则不成矩阵。

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-balloons/[1189. “气球” 的最大数量^]
|{doc_base_url}/1189-maximum-number-of-balloons.adoc[题解]
|✅ 哈希

|{counter:codes2503}
|{leetcode_base_url}/minimum-rectangles-to-cover-points/[3111. 覆盖所有点的最少矩形数目^]
|{doc_base_url}/3111-minimum-rectangles-to-cover-points.adoc[题解]
|✅ 贪心。从左边界开始，尽可能多占用横轴。宽度耗尽，则从下一个点开始。

|{counter:codes2503}
|{leetcode_base_url}/minimum-difference-between-largest-and-smallest-value-in-three-moves/[1509. 三次操作后最大值与最小值的最小差^]
|{doc_base_url}/1509-minimum-difference-between-largest-and-smallest-value-in-three-moves.adoc[题解]
|✅ 贪心。转变一下题目就是要求如何缩短最大值和最小值直接的差值。看官方题解，可以直接求 stem:[a(n - 4 + i) - a(i)] 的最小值。

|{counter:codes2503}
|{leetcode_base_url}/number-of-students-unable-to-eat-lunch/[1700. 无法吃午餐的学生数量^]
|{doc_base_url}/1700-number-of-students-unable-to-eat-lunch.adoc[题解]
|✅

|{counter:codes2503}
|{leetcode_base_url}/pseudo-palindromic-paths-in-a-binary-tree/[1457. 二叉树中的伪回文路径^]
|{doc_base_url}/1457-pseudo-palindromic-paths-in-a-binary-tree.adoc[题解]
|✅ 回溯，深度优先遍历，到叶子节点判断是否可以组成回文。

|{counter:codes2503}
|{leetcode_base_url}/html-entity-parser/[1410. HTML 实体解析器^]
|{doc_base_url}/1410-html-entity-parser.adoc[题解]
|✅ 哈希 + 字符串

|{counter:codes2503}
|{leetcode_base_url}/maximum-number-of-coins-you-can-get/[1561. 你可以获得的最大硬币数目^]
|{doc_base_url}/1561-maximum-number-of-coins-you-can-get.adoc[题解]
|✅ 贪心。每次去第二大的数字即可。

|{counter:codes2503}
|{leetcode_base_url}/delete-leaves-with-a-given-value/[1325. 删除给定值的叶子节点^]
|{doc_base_url}/1325-delete-leaves-with-a-given-value.adoc[题解]
|✅ 深度优先遍历，在“后序”中做业务处理。

|{counter:codes2503}
|{leetcode_base_url}/minimum-cost-to-move-chips-to-the-same-position/[1217. 玩筹码]
|{doc_base_url}/1217-minimum-cost-to-move-chips-to-the-same-position.adoc[题解]
|❌ 题目理解错误！`position[i]` 中的数字是筹码的位置。题目意思是奇数到奇数和偶数到偶数免费，但是紧挨的两个数字移动收费，所以，统计奇偶数的个数，看哪个小就移动哪个。

|{counter:codes2503}
|{leetcode_base_url}/clumsy-factorial/[1006. 笨阶乘^]
|{doc_base_url}/1006-clumsy-factorial.adoc[题解]
|✅ 栈。代码写出来了，但是好烂！

|{counter:codes2503}
|{leetcode_base_url}/keys-and-rooms/[841. 钥匙和房间^]
|{doc_base_url}/0841-keys-and-rooms.adoc[题解]
|✅ 深度优先遍历或广度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/find-and-replace-pattern/[890. 查找和替换模式^]
|{doc_base_url}/0890-find-and-replace-pattern.adoc[题解]
|✅ 映射。建立一个字母映射，并且每个字母只能有一种映射关系。否则就不匹配。

|{counter:codes2503}
|{leetcode_base_url}/grumpy-bookstore-owner/[1052. 爱生气的书店老板^]
|{doc_base_url}/1052-grumpy-bookstore-owner.adoc[题解]
|✅ 先计算没有生气而满意的总数，再计算因为老板憋气而满意的增量用户。

|{counter:codes2503}
|{leetcode_base_url}/moving-stones-until-consecutive/[1033. 移动石子直到连续^]
|{doc_base_url}/1033-moving-stones-until-consecutive.adoc[题解]
|✅ 分类讨论

|{counter:codes2503}
|{leetcode_base_url}/number-of-enclaves/[1020. 飞地的数量^]
|{doc_base_url}/1020-number-of-enclaves.adoc[题解]
|✅ 深度优先遍历。有机会尝试一下广度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/sum-of-root-to-leaf-binary-numbers/[1022. 从根到叶的二进制数之和^]
|{doc_base_url}/1022-sum-of-root-to-leaf-binary-numbers.adoc[题解]
|✅ 深度优先遍历。

|{counter:codes2503}
|{leetcode_base_url}/partition-array-into-disjoint-intervals/[915. 分割数组^]
|{doc_base_url}/0915-partition-array-into-disjoint-intervals.adoc[题解]
|✅ 两遍遍历。有题解可以不到一遍遍历即可解决问题。

|{counter:codes2503}
|{leetcode_base_url}/sort-integers-by-the-power-value/[1387. 将整数按权重排序^]
|{doc_base_url}/1387-sort-integers-by-the-power-value.adoc[题解]
|✅ 先计算每个数字的权重，再进行比较：使用集合存储下标，通过下标找到对应的权重。计算权重时，可以递归，也可以直接循环。使用递归时，可以使用备忘录把已经计算的值存储起来，防止重复计算。

|{counter:codes2503}
|{leetcode_base_url}/path-crossing/[1496. 判断路径是否相交^]
|{doc_base_url}/1496-path-crossing.adoc[题解]
|✅ 想找个巧办法，结果失败！还是用记录轨迹的办法搞定了。

|{counter:codes2503}
|{leetcode_base_url}/delete-nodes-and-return-forest/[1110. 删点成林^]
|{doc_base_url}/1110-delete-nodes-and-return-forest.adoc[题解]
|✅ 深度优先遍历，把父节点传到递归参数里，同时标注一下是左子树还是右子树。

|{counter:codes2503}
|{leetcode_base_url}/count-triplets-that-can-form-two-arrays-of-equal-xor/[1442. 形成两个异或相等数组的三元组数目^]
|{doc_base_url}/1442-count-triplets-that-can-form-two-arrays-of-equal-xor.adoc[题解]
|⭕️ 前缀和。使用官方题解中的异或前缀和解法啦。数学知识还是得补啊！原来的思路是回溯，通过 46 / 47 测试用例。使用回溯应该对，但是加上备忘录后，还是有一个测试用例没通过。（看一个题解，原始解法就是暴力法。是对的。）

|{counter:codes2503}
|{leetcode_base_url}/construct-k-palindrome-strings/[1400. 构造 K 个回文字符串^]
|{doc_base_url}/1400-construct-k-palindrome-strings.adoc[题解]
|⭕️ 统计奇数字母个数，如果个数超过 `k` 肯定就不满足了。自己的思考已经解决答案了。可惜不够确定，还是参考答案了。

|{counter:codes2503}
|{leetcode_base_url}/rle-iterator/[900. RLE 迭代器^]
|{doc_base_url}/0900-rle-iterator.adoc[题解]
|✅ 使用属性 `index` 记录 `next` 到位置，剩下就是在 `encoding` 的偶数下标上做减法。

|{counter:codes2503}
|{leetcode_base_url}/closest-divisors/[1362. 最接近的因数^]
|{doc_base_url}/1362-closest-divisors.adoc[题解]
|✅ 我的解法是从两边向中间挤压；更优解是找到平方根，然后向外开。

|{counter:codes2503}
|{leetcode_base_url}/smallest-subtree-with-all-the-deepest-nodes/[865. 具有所有最深节点的最小子树^]
|{doc_base_url}/0865-smallest-subtree-with-all-the-deepest-nodes.adoc[题解]
|✅ 深度优先遍历，递归，在“后序”阶段处理业务逻辑。

|{counter:codes2503}
|{leetcode_base_url}/camelcase-matching/[1023. 驼峰式匹配^]
|{doc_base_url}/1023-camelcase-matching.adoc[题解]
|✅ 双指针

|{counter:codes2503}
|{leetcode_base_url}/balance-a-binary-search-tree/[1382. 将二叉搜索树变平衡^]
|{doc_base_url}/1382-balance-a-binary-search-tree.adoc[题解]
|✅ 二叉搜索树，先中序遍历拿到所有节点，然后递归构造平衡二叉搜索树。

|{counter:codes2503}
|{leetcode_base_url}/minimum-domino-rotations-for-equal-row/[1007. 行相等的最少多米诺旋转^]
|{doc_base_url}/1007-minimum-domino-rotations-for-equal-row.adoc[题解]
|✅ 统计每个数字的下标，然后逐个检查每个数字的下标集合是否能完整覆盖原始数字的全部下标。更优解：判断是否可以都变成 `tops[0]` 或者 `bottoms[0]`。


|===

截止目前，本轮练习一共完成 {codes2503} 道题。
