[#logbook-202601]
= 2026年 刷题日志

ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]

== 刷题日志

[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2601}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|❌ 求连续序列长度，可以先去重，再寻找当前序列起点，从起点向后查找，出现断点，则当前序列结束。取所有序列中，最长值即可。

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划。楼梯顶部是比数组长度更长的一节。先写暴力破解，再备忘录，再进会到动态规划。

|{counter:corrections}
|{leetcode_base_url}/combination-sum-iv/[377. 组合总和 Ⅳ^]
|{doc_base_url}/0377-combination-sum-iv.adoc[题解]
|❌ 动态规划。在以往的思维定式中，爬楼梯总是: stem:[f(i)=f(i−1)+f(i−2)]。这道题突破了这个思维定式，爬楼梯也可以：stem:[$f(i) = \sum\limits_{j=0}^{n-1}{f(i-nums[j\])}$]。

|{counter:codes}
|{leetcode_base_url}/count-ways-to-build-good-strings/[2466. 统计构造好字符串的方案数^]
|{doc_base_url}/2466-count-ways-to-build-good-strings.adoc[题解]
|✅ 动态规划。爬楼梯解法：stem:[$f(i) = f(i−zero) + f(i − one)$]

|{counter:codes}
|{leetcode_base_url}/count-number-of-texts/[2266. 统计打字方案数^]
|{doc_base_url}/2266-count-number-of-texts.adoc[题解]
|✅ 动态规划。将字符串按照相同字符进行切割，根据加法原理，每个子串内部是“爬楼梯”：每个按键上面有 `3` 或 `4` 个字母，那么按键列表，就可以有 `1~3` 或 `1~4` 个按键按出一个字母，这就是爬楼梯：stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)$] 或 stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)+f(i-4)$]；子串之间，根据乘法原理，直接相乘。

|{counter:corrections}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|✅ 单调栈。统计出每个字符的数量，再加上一个是否添加过的标记，使用单调栈，将大的字符弹出，再添加小字符。这样就可以保证小字符尽可能在前面了。与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. 去除重复字母] 相同，不再赘述。

|{counter:corrections}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。有点脑筋急转弯！看答案也是一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/count-number-of-ways-to-place-houses/[2320. 统计放置房子的方式数^]
|{doc_base_url}/2320-count-number-of-ways-to-place-houses.adoc[题解]
|✅ 动态规划。先只考虑一边的情况，再组合两边的情况。只考虑一边的情况，就是一个斐波那契数列： stem:[$f(i) = f(i-1) + f(i-2)$]。

|{counter:corrections}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|❌ 回溯。先找出波峰波谷节点，然后对波峰做全排列，针对每个排列与波谷求移动距离，最后取最小值。

|{counter:corrections}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。以为是回溯，但是回溯超时（152/182）。看答案，发现是滑动窗口。定长窗口，每次滑动距离为单词长度。

|===



截止目前，本轮练习一共完成 {codes2601} 道题。
