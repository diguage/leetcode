[#logbook-202601]
= 2026年 刷题日志

ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]

== 刷题日志

[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2601}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|❌ 求连续序列长度，可以先去重，再寻找当前序列起点，从起点向后查找，出现断点，则当前序列结束。取所有序列中，最长值即可。

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划。楼梯顶部是比数组长度更长的一节。先写暴力破解，再备忘录，再进会到动态规划。

|{counter:corrections}
|{leetcode_base_url}/combination-sum-iv/[377. 组合总和 Ⅳ^]
|{doc_base_url}/0377-combination-sum-iv.adoc[题解]
|❌ 动态规划。在以往的思维定式中，爬楼梯总是: stem:[f(i)=f(i−1)+f(i−2)]。这道题突破了这个思维定式，爬楼梯也可以：stem:[$f(i) = \sum\limits_{j=0}^{n-1}{f(i-nums[j\])}$]。

|{counter:codes}
|{leetcode_base_url}/count-ways-to-build-good-strings/[2466. 统计构造好字符串的方案数^]
|{doc_base_url}/2466-count-ways-to-build-good-strings.adoc[题解]
|✅ 动态规划。爬楼梯解法：stem:[$f(i) = f(i−zero) + f(i − one)$]

|{counter:codes}
|{leetcode_base_url}/count-number-of-texts/[2266. 统计打字方案数^]
|{doc_base_url}/2266-count-number-of-texts.adoc[题解]
|✅ 动态规划。将字符串按照相同字符进行切割，根据加法原理，每个子串内部是“爬楼梯”：每个按键上面有 `3` 或 `4` 个字母，那么按键列表，就可以有 `1~3` 或 `1~4` 个按键按出一个字母，这就是爬楼梯：stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)$] 或 stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)+f(i-4)$]；子串之间，根据乘法原理，直接相乘。

|{counter:corrections}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|✅ 单调栈。统计出每个字符的数量，再加上一个是否添加过的标记，使用单调栈，将大的字符弹出，再添加小字符。这样就可以保证小字符尽可能在前面了。与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. 去除重复字母] 相同，不再赘述。

|{counter:corrections}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。有点脑筋急转弯！看答案也是一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/count-number-of-ways-to-place-houses/[2320. 统计放置房子的方式数^]
|{doc_base_url}/2320-count-number-of-ways-to-place-houses.adoc[题解]
|✅ 动态规划。先只考虑一边的情况，再组合两边的情况。只考虑一边的情况，就是一个斐波那契数列： stem:[$f(i) = f(i-1) + f(i-2)$]。

|{counter:corrections}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|❌ 回溯。先找出波峰波谷节点，然后对波峰做全排列，针对每个排列与波谷求移动距离，最后取最小值。

|{counter:corrections}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。以为是回溯，但是回溯超时（152/182）。看答案，发现是滑动窗口。定长窗口，每次滑动距离为单词长度。

|{counter:corrections}
|{leetcode_base_url}/longest-valid-parentheses/[32. 最长有效括号^]
|{doc_base_url}/0032-longest-valid-parentheses.adoc[题解]
|❌ 栈。也可以用动态规划。有一点想不明白，在使用标记数组时，为什么可以直接设置栈顶和当前元素指定下标为 `true`，中间肯定都是 `true` 吗？

|{counter:corrections}
|{leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^]
|{doc_base_url}/0084-largest-rectangle-in-histogram.adoc[题解]
|✅ 单调栈。使用单调递增栈，有更高元素就压栈，有低于栈顶的元素，就出栈，计算栈顶元素到当前元素之间的面积。两边加上高度为 `0` 的哨兵，可以极大简化代码。

|{counter:corrections}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string/[1047. 删除字符串中的所有相邻重复项^]
|{doc_base_url}/1047-remove-all-adjacent-duplicates-in-string.adoc[题解]
|✅ 栈。栈为空，则入栈。不空，则比较最后一个字母和当前字母是否相同，相同则弹出，否则就追加。

|{counter:codes}
|{leetcode_base_url}/maximum-total-damage-with-spell-casting/[3186. 施咒的最大总伤害^]
|{doc_base_url}/3186-maximum-total-damage-with-spell-casting.adoc[题解]
|❌ 动态规划。有点绕，需要把原始数组，按照伤害值转化成新的数组，这样就可以在新数组上，使用类似“打家劫舍”的套路来解题了。与“打家劫舍”套路不同的是，这里“选”的时候，前面被选择的项不是一个固定的项，是根据伤害条件选择出来的项。

|{counter:corrections}
|{leetcode_base_url}/last-stone-weight-ii/[1049. 最后一块石头的重量 II^]
|{doc_base_url}/1049-last-stone-weight-ii.adoc[题解]
|❌ 动态规划。将题目转换成把石头分成两堆，求两堆重量的最小差值。那么，最小差值，就是两堆重量相等。那么，题目就转换成在一堆石头中选择一些石头让其重量尽可能达到总重量的一半。题目结果就是总重量减去二倍的选择石头最大可能拼凑出来的重量。这就是 0/1 背包问题了。

|{counter:corrections}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|⭕️ 回溯。有思路，没写出来。看来回溯还是得多练啊！

|{counter:corrections}
|{leetcode_base_url}/basic-calculator/[224. 基本计算器^]
|{doc_base_url}/0224-basic-calculator.adoc[题解]
|❌ 栈。官方题解的思路将括号展开。代码非常简洁，整体思路还要再思路一下。

|{counter:corrections}
|{leetcode_base_url}/single-number-ii/[137. 只出现一次的数字 II^]
|{doc_base_url}/0137-single-number-ii.adoc[题解]
|❌ 位运算。每个数字的每位相加，除以 `3`，余数即为唯一数。从二进制转换成十进制，可以通过“移位”+“相或”来完成。

|===



截止目前，本轮练习一共完成 {codes2601} 道题。
