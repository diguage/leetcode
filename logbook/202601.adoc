[#logbook-202601]
= 2026年 刷题日志

ifndef::leetcode_base_url[]
:leetcode_base_url: https://leetcode.com/problems
endif::[]

ifndef::doc_base_url[]
:doc_base_url: link:../docs
endif::[]

== 刷题日志

[cols="7,30,7,56",options="header"]
|===
|序号 |题目 |题解 |备注

|{counter:codes2601}
|{leetcode_base_url}/longest-consecutive-sequence/[128. 最长连续序列^]
|{doc_base_url}/0128-longest-consecutive-sequence.adoc[题解]
|❌ 求连续序列长度，可以先去重，再寻找当前序列起点，从起点向后查找，出现断点，则当前序列结束。取所有序列中，最长值即可。

|{counter:codes2503}
|{leetcode_base_url}/min-cost-climbing-stairs/[746. 使用最小花费爬楼梯^]
|{doc_base_url}/0746-min-cost-climbing-stairs.adoc[题解]
|✅ 动态规划。楼梯顶部是比数组长度更长的一节。先写暴力破解，再备忘录，再进会到动态规划。

|{counter:corrections}
|{leetcode_base_url}/combination-sum-iv/[377. 组合总和 Ⅳ^]
|{doc_base_url}/0377-combination-sum-iv.adoc[题解]
|❌ 动态规划。在以往的思维定式中，爬楼梯总是: stem:[f(i)=f(i−1)+f(i−2)]。这道题突破了这个思维定式，爬楼梯也可以：stem:[$f(i) = \sum\limits_{j=0}^{n-1}{f(i-nums[j\])}$]。

|{counter:codes}
|{leetcode_base_url}/count-ways-to-build-good-strings/[2466. 统计构造好字符串的方案数^]
|{doc_base_url}/2466-count-ways-to-build-good-strings.adoc[题解]
|✅ 动态规划。爬楼梯解法：stem:[$f(i) = f(i−zero) + f(i − one)$]

|{counter:codes}
|{leetcode_base_url}/count-number-of-texts/[2266. 统计打字方案数^]
|{doc_base_url}/2266-count-number-of-texts.adoc[题解]
|✅ 动态规划。将字符串按照相同字符进行切割，根据加法原理，每个子串内部是“爬楼梯”：每个按键上面有 `3` 或 `4` 个字母，那么按键列表，就可以有 `1~3` 或 `1~4` 个按键按出一个字母，这就是爬楼梯：stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)$] 或 stem:[$f(i) = f(i-1)+f(i-2)+f(i-3)+f(i-4)$]；子串之间，根据乘法原理，直接相乘。

|{counter:corrections}
|{leetcode_base_url}/smallest-subsequence-of-distinct-characters/[1081. 不同字符的最小子序列^]
|{doc_base_url}/1081-smallest-subsequence-of-distinct-characters.adoc[题解]
|✅ 单调栈。统计出每个字符的数量，再加上一个是否添加过的标记，使用单调栈，将大的字符弹出，再添加小字符。这样就可以保证小字符尽可能在前面了。与 {doc_base_url}/0316-remove-duplicate-letters.adoc[316. 去除重复字母] 相同，不再赘述。

|{counter:corrections}
|{leetcode_base_url}/first-day-where-you-have-been-in-all-the-rooms/[1997. 访问完所有房间的第一天^]
|{doc_base_url}/1997-first-day-where-you-have-been-in-all-the-rooms.adoc[题解]
|❌ 动态规划。有点脑筋急转弯！看答案也是一脸懵逼！

|{counter:codes2503}
|{leetcode_base_url}/count-number-of-ways-to-place-houses/[2320. 统计放置房子的方式数^]
|{doc_base_url}/2320-count-number-of-ways-to-place-houses.adoc[题解]
|✅ 动态规划。先只考虑一边的情况，再组合两边的情况。只考虑一边的情况，就是一个斐波那契数列： stem:[$f(i) = f(i-1) + f(i-2)$]。

|{counter:corrections}
|{leetcode_base_url}/minimum-moves-to-spread-stones-over-grid/[2850. 将石头分散到网格图的最少移动次数^]
|{doc_base_url}/2850-minimum-moves-to-spread-stones-over-grid.adoc[题解]
|❌ 回溯。先找出波峰波谷节点，然后对波峰做全排列，针对每个排列与波谷求移动距离，最后取最小值。

|{counter:corrections}
|{leetcode_base_url}/substring-with-concatenation-of-all-words/[30. 串联所有单词的子串^]
|{doc_base_url}/0030-substring-with-concatenation-of-all-words.adoc[题解]
|❌ 滑动窗口。以为是回溯，但是回溯超时（152/182）。看答案，发现是滑动窗口。定长窗口，每次滑动距离为单词长度。

|{counter:corrections}
|{leetcode_base_url}/longest-valid-parentheses/[32. 最长有效括号^]
|{doc_base_url}/0032-longest-valid-parentheses.adoc[题解]
|❌ 栈。也可以用动态规划。有一点想不明白，在使用标记数组时，为什么可以直接设置栈顶和当前元素指定下标为 `true`，中间肯定都是 `true` 吗？

|{counter:corrections}
|{leetcode_base_url}/largest-rectangle-in-histogram/[84. 柱状图中最大的矩形^]
|{doc_base_url}/0084-largest-rectangle-in-histogram.adoc[题解]
|✅ 单调栈。使用单调递增栈，有更高元素就压栈，有低于栈顶的元素，就出栈，计算栈顶元素到当前元素之间的面积。两边加上高度为 `0` 的哨兵，可以极大简化代码。

|{counter:corrections}
|{leetcode_base_url}/remove-all-adjacent-duplicates-in-string/[1047. 删除字符串中的所有相邻重复项^]
|{doc_base_url}/1047-remove-all-adjacent-duplicates-in-string.adoc[题解]
|✅ 栈。栈为空，则入栈。不空，则比较最后一个字母和当前字母是否相同，相同则弹出，否则就追加。

|{counter:codes}
|{leetcode_base_url}/maximum-total-damage-with-spell-casting/[3186. 施咒的最大总伤害^]
|{doc_base_url}/3186-maximum-total-damage-with-spell-casting.adoc[题解]
|❌ 动态规划。有点绕，需要把原始数组，按照伤害值转化成新的数组，这样就可以在新数组上，使用类似“打家劫舍”的套路来解题了。与“打家劫舍”套路不同的是，这里“选”的时候，前面被选择的项不是一个固定的项，是根据伤害条件选择出来的项。

|{counter:corrections}
|{leetcode_base_url}/last-stone-weight-ii/[1049. 最后一块石头的重量 II^]
|{doc_base_url}/1049-last-stone-weight-ii.adoc[题解]
|❌ 动态规划。将题目转换成把石头分成两堆，求两堆重量的最小差值。那么，最小差值，就是两堆重量相等。那么，题目就转换成在一堆石头中选择一些石头让其重量尽可能达到总重量的一半。题目结果就是总重量减去二倍的选择石头最大可能拼凑出来的重量。这就是 0/1 背包问题了。

|{counter:corrections}
|{leetcode_base_url}/sudoku-solver/[37. 解数独^]
|{doc_base_url}/0037-sudoku-solver.adoc[题解]
|⭕️ 回溯。有思路，没写出来。看来回溯还是得多练啊！

|{counter:corrections}
|{leetcode_base_url}/basic-calculator/[224. 基本计算器^]
|{doc_base_url}/0224-basic-calculator.adoc[题解]
|❌ 栈。官方题解的思路将括号展开。代码非常简洁，整体思路还要再思路一下。

|{counter:corrections}
|{leetcode_base_url}/single-number-ii/[137. 只出现一次的数字 II^]
|{doc_base_url}/0137-single-number-ii.adoc[题解]
|❌ 位运算。每个数字的每位相加，除以 `3`，余数即为唯一数。从二进制转换成十进制，可以通过“移位”+“相或”来完成。

|{counter:corrections}
|{leetcode_base_url}/single-number-iii/[260. 只出现一次的数字 III^]
|{doc_base_url}/0260-single-number-iii.adoc[题解]
|❌ 位运算。所有数字异或，相同的数字都会被抵消掉，只剩下只出现一次的数字。然后，根据二进制表示中最后出现的 `1`（因为只出现一次数字在该位上不一样），将数字分成两组，再分别亦或，即可得到两个数字。

|{counter:corrections}
|{leetcode_base_url}/distinct-subsequences/[115. 不同的子序列^]
|{doc_base_url}/0115-distinct-subsequences.adoc[题解]
|⭕️ 动态规划。看到动态规划的提示，用矩阵模拟“凑数”给凑出来的解法。

|{counter:corrections}
|{leetcode_base_url}/number-of-good-leaf-nodes-pairs/[1530. 好叶子节点对的数量^]
|{doc_base_url}/1530-number-of-good-leaf-nodes-pairs.adoc[题解]
|✅ 深度优先遍历。需要记录符合“好叶子节点”的数量。无需记录所有路径，只需要记录符合要求的路径的数量即可。

|{counter:corrections}
|{leetcode_base_url}/remove-zero-sum-consecutive-nodes-from-linked-list/[1171. 从链表中删去总和值为零的连续节点^]
|{doc_base_url}/1171-remove-zero-sum-consecutive-nodes-from-linked-list.adoc[题解]
|✅ 前缀和。计算前缀和，并保存到 `Map` 中，如果出现了相同的前缀和，证明中间一段的值相加为 `0`，去掉中间一段即可。

|{counter:corrections}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-ii/[122. 买卖股票的最佳时机 II]
|{doc_base_url}/0122-best-time-to-buy-and-sell-stock-ii.adoc[题解]
|⭕️ 动态规划。这道题更好的解法是贪心算法。这次从动态规划的角度去看这个问题：“满仓”是继承或者买入；空仓则是继承或者卖出。

|{counter:corrections}
|{leetcode_base_url}/best-time-to-buy-and-sell-stock-iii/[123. 买卖股票的最佳时机 III^]
|{doc_base_url}/0123-best-time-to-buy-and-sell-stock-iii.adoc[题解]
|⭕️ 动态规划。在 {doc_base_url}/0122-best-time-to-buy-and-sell-stock-ii.adoc[题解] 的基础上，增加了交易次数限制。思路懂了，边界条件总是不对。还要再思考。

|{counter:corrections}
|{leetcode_base_url}/cheapest-flights-within-k-stops/[787. K 站中转内最便宜的航班^]
|{doc_base_url}/0787-cheapest-flights-within-k-stops.adoc[题解]
|⭕ 深度优先遍历。动态规划的题目，先用深度优先遍历暴力破解一下。题目理解错了：是最多经过 k 站中转。

|{counter:corrections}
|{leetcode_base_url}/longest-increasing-subsequence/[300. 最长递增子序列^]
|{doc_base_url}/0300-longest-increasing-subsequence.adoc[题解]
|❌ 动态规划。将每个值跟前面所有值相比，当比其大时，在其之上加一。动态规划总想直接从一个值中获取，没想到还需要遍历。

|{counter:codes}
|{leetcode_base_url}/longest-common-subsequence/[1143. Longest Common Subsequence^]
|{doc_base_url}/1143-longest-common-subsequence.adoc[题解]
|✅ 动态规划。

|{counter:corrections}
|{leetcode_base_url}/shortest-string-that-contains-three-strings/[2800. 包含三个字符串的最短字符串^]
|{doc_base_url}/2800-shortest-string-that-contains-three-strings.adoc[题解]
|❌ 回溯。先回溯，找出所有排列；然后，再将每个组合合并成字符串。这个过程中，会有两种“包含”关系，出现即返回长字符串。没有包含关系，就判断一个字符串前缀是否是另外一个字符串的结尾。

|{counter:corrections}
|{leetcode_base_url}/maximum-sum-circular-subarray/[918. 环形子数组的最大和^]
|{doc_base_url}/0918-maximum-sum-circular-subarray.adoc[题解]
|❌ 动态规划。利用 {doc_base_url}/0053-maximum-subarray.adoc[53. 最大子数组和^] 的解法，求出最大子数组和最小子数组。再根据最大子数组和是否大于 `0`，来决定如何返回。

|{counter:corrections}
|{leetcode_base_url}/maximum-students-taking-exam/[1349. 参加考试的最大学生数^]
|{doc_base_url}/1349-maximum-students-taking-exam.adoc[题解]
|❌ 动态规划。看了答案也是一脸懵逼，尤其是位运算，还需要多多练习。

|{counter:corrections}
|{leetcode_base_url}/decode-ways/[91. 解码方法^]
|{doc_base_url}/0091-decode-ways.adoc[题解]
|✅ 动态规划。从后向前，一个字符或者两个字符来判断是否可以编码成字母，然后递归调用直到字符串尽头。

|{counter:corrections}
|{leetcode_base_url}/minimum-cost-to-move-chips-to-the-same-position/[1217. 玩筹码^]
|{doc_base_url}/1217-minimum-cost-to-move-chips-to-the-same-position.adoc[题解]
|❌ 有点脑筋急转弯的感觉。左右移动两位免费，相当于奇数合并免费，偶数合并免费，相邻的偶数和奇数合并收费，统计奇数和偶数的数量，然后哪个少移动哪个就可以了。

|{counter:corrections}
|{leetcode_base_url}/count-triplets-that-can-form-two-arrays-of-equal-xor/[1442. 形成两个异或相等数组的三元组数目^]
|{doc_base_url}/1442-count-triplets-that-can-form-two-arrays-of-equal-xor.adoc[题解]
|✅ 位运算。直接暴力计算了。异或运算，支持交换律，结合律。再通过推演可知： stem:[$S_i \oplus S_j = S_j \oplus S_{k+1}$] => stem:[$S_i = S_{k+1}$]。所以，可以通过计算前缀异或来加速整个过程。

|{counter:corrections}
|{leetcode_base_url}/construct-k-palindrome-strings/[1400. 构造 K 个回文字符串^]
|{doc_base_url}/1400-construct-k-palindrome-strings.adoc[题解]
|❌ 有点脑筋急转弯+数学的感觉。`K` 的长度要小于等于字符串长度并且奇数次字符为 `0` 或小于 `K` 才能满足条件。

|{counter:corrections}
|{leetcode_base_url}/candy/[135. 分发糖果^]
|{doc_base_url}/0135-candy.adoc[题解]
|✅ 贪心算法。先从左向右遍历，当右边高于左边，则在左边基础上加 `1`；然后再从右向左，当左边高并且左边糖果少，则在右边基础上加 `1`。最后求和。

|{counter:corrections}
|{leetcode_base_url}/max-points-on-a-line/[149. 直线上最多的点数^]
|{doc_base_url}/0149-max-points-on-a-line.adoc[题解]
|⭕️ 数学。三点之间两两求斜率，斜率相等则共线。通过属性计算，可以避免出现浮点数。

|{counter:corrections}
|{leetcode_base_url}/bitwise-and-of-numbers-range/[201. 数字范围按位与^]
|{doc_base_url}/0201-bitwise-and-of-numbers-range.adoc[题解]
|⭕️ 位运算。暴力破解超时。对于大于 `left` 的前面的 `1` 都会成为 `0`，可以忽略。在 `left` 和 `right` 之间，要么是中间相同，要么是全部不同。所以，可以通过异或，求出后面的不同之处的位数，然后移位减一取反，再相与即可求出“前缀”。

|{counter:corrections}
|{leetcode_base_url}/word-search-ii/[212. 单词搜索 II^]
|{doc_base_url}/0212-word-search-ii.adoc[题解]
|✅ 前缀树+回溯。只用回溯超时。前缀树+回溯，通过测试。

|{counter:corrections}
|{leetcode_base_url}/evaluate-division/[399. 除法求值^]
|{doc_base_url}/0399-evaluate-division.adoc[题解]
|❌ 并查集。带权重的并查集，还要多练习。

|{counter:corrections}
|{leetcode_base_url}/minimum-genetic-mutation/[433. 最小基因变化^]
|{doc_base_url}/0433-minimum-genetic-mutation.adoc[题解]
|⭕️ ✅ 广度优先遍历。对基因每个可能的变异都要要做遍历。

|{counter:corrections}
|{leetcode_base_url}/ipo/[502. IPO^]
|{doc_base_url}/0502-ipo.adoc[题解]
|⭕️ 贪心算法。每次都获取当前可以获取收益的最大值。

|{counter:corrections}
|{leetcode_base_url}/rectangle-area/[223. 矩形面积^]
|{doc_base_url}/0223-rectangle-area.adoc[题解]
|⭕️ 有点着急。再细想一下。

|{counter:corrections}
|{leetcode_base_url}/text-justification/[68. 文本左右对齐^]
|{doc_base_url}/0068-text-justification.adoc[题解]
|✅ 看了题解，按照单单词行、多单词行和尾行分三种情况分别处理写出来的。

|{counter:corrections}
|{leetcode_base_url}/interleaving-string/[97. 交错字符串^]
|{doc_base_url}/0097-interleaving-string.adoc[题解]
|❌ 动态规划。将其转化成表格走路的思路来解决。需要先从各个字符串中，寻找出前缀字符串。

|{counter:corrections}
|{leetcode_base_url}/wildcard-matching/[44. 通配符匹配^]
|{doc_base_url}/0044-wildcard-matching.adoc[题解]
|❌ 动态规划。`p` 是字母或 `?` 时，状态是确定的。当 `p` 是 `*` 时，状态转移方程就可以分为使用该 `*` 和不使用两种情况。

|{counter:corrections}
|{leetcode_base_url}/maximal-rectangle/[85. 最大矩形^]
|{doc_base_url}/0085-maximal-rectangle.adoc[题解]
|❌ 单调栈。统计每行的高度，从上往下长，逐行长高，逐行计算最大矩阵面积。使用 {doc_base_url}/0084-largest-rectangle-in-histogram.adoc[84.柱状图中最大的矩形] 的思路，逐行求最大矩形。

|{counter:corrections}
|{leetcode_base_url}/majority-element-ii/[229. 多数元素 II^]
|{doc_base_url}/0229-majority-element-ii.adoc[题解]
|❌ 摩尔投票法。针对多个候选项的摩尔投票法，还是需要多思考，多练习。

|{counter:corrections}
|{leetcode_base_url}/minimum-height-trees/[310. 最小高度树^]
|{doc_base_url}/0310-minimum-height-trees.adoc[题解]
|❌ 广度优先遍历。剪窗花思路：从外围（度为 `1` 的节点）向里靠拢，到最后就只剩下目标节点了。

|{counter:corrections}
|{leetcode_base_url}/bulb-switcher/[319. 灯泡开关^]
|{doc_base_url}/0319-bulb-switcher.adoc[题解]
|⭕️ 数学题。多模拟几个数字，观察出寻找公约数为奇数的灯（公约数为偶数则会打开再关闭）会被保持打开状态。公约数都是成对出现，除非两个数重叠就是一个数，那么这种数就是完全平方数。所以，只需要求完全平方数的个数即可。

|{counter:corrections}
|{leetcode_base_url}/super-pow/[372. 超级次方^]
|{doc_base_url}/0372-super-pow.adoc[题解]
|⭕️ 分治+数学运算。利用 stem:[(a⋅b) mod m=[(a mod m)⋅(b mod m)\] mod m] 和 stem:[(a^10)^10] 计算变换为反复计算 stem:[a = (a^10)] 提高高次幂。进一步组合，搞定该题。

|{counter:corrections}
|{leetcode_base_url}/wiggle-subsequence/[376. 摆动序列^]
|{doc_base_url}/0376-wiggle-subsequence.adoc[题解]
|❌ 贪心算法。简单概括：遇到升序序列，则从降序序列增长；如果遇到降序序列，则从升序序列增长。

|{counter:codes}
|{leetcode_base_url}/keyboard-row/[500. 键盘行^]
|{doc_base_url}/0500-keyboard-row.adoc[题解]
|✅ 哈希。记录每行字母的下标。查看每个单词第一个字母的下标，然后再对比后续单词下标，有不一致的则出局。

|{counter:codes}
|{leetcode_base_url}/base-7/[504. 七进制数^]
|{doc_base_url}/0504-base-7.adoc[题解]
|✅ 模拟。进制转换。

|{counter:codes}
|{leetcode_base_url}/relative-ranks/[506. Relative Ranks^]
|{doc_base_url}/0506-relative-ranks.adoc[题解]
|✅ 哈希+排序。

|{counter:codes}
|{leetcode_base_url}/perfect-number/[507. Perfect Number^]
|{doc_base_url}/0507-perfect-number.adoc[题解]
|✅ 模拟计算。



|===



截止目前，本轮练习一共完成 {codes2601} 道题。
